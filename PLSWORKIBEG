if getgenv().eclipsehub then warn("Eclipse Hub is already executed") return end
getgenv().eclipsehub = true

-- No virtualization function wrapper
loadstring([[
    function LPH_NO_VIRTUALIZE(f) return f end;
]])()

-- Services
local debris = game:GetService("Debris")
local contentProvider = game:GetService("ContentProvider")
local scriptContext = game:GetService("ScriptContext")
local players = game:GetService("Players")
local tweenService = game:GetService("TweenService")
local statsService = game:GetService("Stats")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local httpService = game:GetService("HttpService")
local starterGui = game:GetService("StarterGui")

-- Variables
local player = players.LocalPlayer
local mouse = player:GetMouse()
local camera = workspace.CurrentCamera
local values = replicatedStorage:FindFirstChild("Values")

local IS_PRACTICE = game.PlaceId == 8206123457
local IS_SOLARA = string.match(getexecutorname(), "Solara")
local AC_BYPASS = IS_PRACTICE

local moveToUsing = {}

-- Initialize values if needed
if not values or IS_PRACTICE then
	if replicatedStorage:FindFirstChild("Values") then
		replicatedStorage:FindFirstChild("Values"):Destroy()
	end
	values = Instance.new("Folder")
	local status = Instance.new("StringValue")
	status.Name = "Status"
	status.Value = "InPlay"
	status.Parent = values
	values.Parent = replicatedStorage
	values.Name = "Values"
end

if not LPH_OBFUSCATED then
    getfenv().LPH_NO_VIRTUALIZE = function(f) return f end
end

-- Anti-Cheat Bypass
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Handshake = ReplicatedStorage.Remotes.CharacterSoundEvent
local Hooks = {}
local HandshakeInts = {}

LPH_NO_VIRTUALIZE(function()
    for i, v in getgc() do
        if typeof(v) == "function" and islclosure(v) then
            if (#getprotos(v) == 1) and table.find(getconstants(getproto(v, 1)), 4000001) then
                hookfunction(v, function() end)
            end
        end
    end
end)()

Hooks.__namecall = hookmetamethod(game, "__namecall", LPH_NO_VIRTUALIZE(function(self, ...)
    local Method = getnamecallmethod()
    local Args = {...}

    if not checkcaller() and (self == Handshake) and (Method == "fireServer") and (string.find(Args[1], "AC")) then
        if (#HandshakeInts == 0) then
            HandshakeInts = {table.unpack(Args[2], 2, 18)}
        else
            for i, v in HandshakeInts do
                Args[2][i + 1] = v
            end
        end
    end

    return Hooks.__namecall(self, ...)
end))

task.wait(1)

if not isfolder("eclipsehub") then
	makefolder("eclipsehub")
end

-- Initialize ping and fps counters
local ping = 0
local fps = 0

-- Utility Functions
function getPing()
	return statsService.PerformanceStats.Ping:GetValue()
end

function getServerPing()
	return statsService.Network.ServerStatsItem['Data Ping']:GetValue()
end

function findClosestBall()
	local lowestDistance = math.huge
	local nearestBall = nil

	local character = player.Character

	for index, ball in pairs(workspace:GetChildren()) do
		if ball.Name ~= "Football" then continue end
		if not ball:IsA("BasePart") then continue end
		if not character:FindFirstChild("HumanoidRootPart") then continue end
		local distance = (ball.Position - character.HumanoidRootPart.Position).Magnitude

		if distance < lowestDistance then
			nearestBall = ball
			lowestDistance = distance
		end
	end

	return nearestBall
end

-- Create hitbox visualization part
local part = Instance.new("Part")
part.Transparency = 0.5 -- More visible than before
part.Anchored = true
part.CanCollide = false
part.CastShadow = false
part.Color = Color3.fromRGB(52, 152, 219) -- Light blue color
part.Shape = Enum.PartType.Ball -- Make it a sphere
part.Material = Enum.Material.ForceField -- Nice effect
part.Parent = nil -- Don't put in workspace until needed

function beamProjectile(g, v0, x0, t1)
	local c = 0.5*0.5*0.5;
	local p3 = 0.5*g*t1*t1 + v0*t1 + x0;
	local p2 = p3 - (g*t1*t1 + v0*t1)/3;
	local p1 = (c*g*t1*t1 + 0.5*v0*t1 + x0 - c*(x0+p3))/(3*c) - p2;

	local curve0 = (p1 - x0).magnitude;
	local curve1 = (p2 - p3).magnitude;

	local b = (x0 - p3).unit;
	local r1 = (p1 - x0).unit;
	local u1 = r1:Cross(b).unit;
	local r2 = (p2 - p3).unit;
	local u2 = r2:Cross(b).unit;
	b = u1:Cross(r1).unit;

	local cf1 = CFrame.new(
		x0.x, x0.y, x0.z,
		r1.x, u1.x, b.x,
		r1.y, u1.y, b.y,
		r1.z, u1.z, b.z
	)

	local cf2 = CFrame.new(
		p3.x, p3.y, p3.z,
		r2.x, u2.x, b.x,
		r2.y, u2.y, b.y,
		r2.z, u2.z, b.z
	)

	return curve0, -curve1, cf1, cf2;
end

function getNearestPartToPartFromParts(part, parts)
	local lowestDistance = math.huge
	local nearestPart = nil

	for index, p in pairs(parts) do
		local distance = (part.Position - p.Position).Magnitude

		if distance < lowestDistance then
			nearestPart = p
			lowestDistance = distance
		end
	end

	return nearestPart
end

function findPossessor()
	for index, player in pairs(players:GetPlayers()) do
		local character = player.Character; if not character then continue end
		if not character:FindFirstChildWhichIsA("Tool") then continue end
		return player.Character
	end
end

-- Start ping and fps update threads
task.spawn(function()
	while true do
		task.wait(0.1)
		ping = ( getPing() + getServerPing() ) / 1000
	end
end)

task.spawn(function()
	runService.RenderStepped:Connect(function()
		fps += 1
		task.delay(1, function()
			fps -= 1
		end)
	end)
end)

-- Custom Eclipse Hub UI Implementation
-- Define the light blue colors for the Eclipse Hub theme
local THEME = {
    MainBackground = Color3.fromRGB(20, 20, 20),  -- Dark background
    SecondaryBackground = Color3.fromRGB(30, 30, 30),  -- Slightly lighter background
    AccentColor = Color3.fromRGB(52, 152, 255),  -- Light blue accent (main feature)
    AccentColorDarker = Color3.fromRGB(41, 128, 255),  -- Darker blue for hover effects
    TextColor = Color3.fromRGB(255, 255, 255),  -- White text
    SubTextColor = Color3.fromRGB(200, 200, 200),  -- Light gray for secondary text
    BorderColor = Color3.fromRGB(40, 40, 40),  -- Dark border
    SliderBackground = Color3.fromRGB(40, 40, 40),  -- Background for sliders
    ToggleOn = Color3.fromRGB(52, 152, 255),  -- Light blue for enabled toggles
    ToggleOff = Color3.fromRGB(130, 130, 130),  -- Gray for disabled toggles
}

-- Create a custom UI library for Eclipse Hub
local EclipseUI = {}
EclipseUI.ToggleItems = {}
EclipseUI.Windows = {}
EclipseUI.Modules = {}
EclipseUI.Categories = {}
EclipseUI.ActiveCategory = nil

-- Create the main ScreenGui container
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "EclipseHub"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = (gethui and gethui()) or game:GetService("CoreGui")

-- Create the main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.BackgroundColor3 = THEME.MainBackground
mainFrame.BorderColor3 = THEME.BorderColor
mainFrame.BorderSizePixel = 0
mainFrame.Position = UDim2.new(0.5, -300, 0.5, -225)
mainFrame.Size = UDim2.new(0, 600, 0, 450)
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui

-- Add corner rounding to the main frame
local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 10)
mainCorner.Parent = mainFrame

-- Create title bar
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.BackgroundColor3 = THEME.SecondaryBackground
titleBar.BorderSizePixel = 0
titleBar.Size = UDim2.new(1, 0, 0, 40)
titleBar.Parent = mainFrame

-- Add corner rounding to title bar (top corners only)
local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 10)
titleCorner.Parent = titleBar

-- Fix for the title bar to only have rounded top corners
local titleBarFix = Instance.new("Frame")
titleBarFix.Name = "TitleBarFix"
titleBarFix.BackgroundColor3 = THEME.SecondaryBackground
titleBarFix.BorderSizePixel = 0
titleBarFix.Position = UDim2.new(0, 0, 0.5, 0)
titleBarFix.Size = UDim2.new(1, 0, 0.5, 0)
titleBarFix.Parent = titleBar

-- Title text
local titleText = Instance.new("TextLabel")
titleText.Name = "Title"
titleText.BackgroundTransparency = 1
titleText.Position = UDim2.new(0, 20, 0, 0)
titleText.Size = UDim2.new(0, 200, 1, 0)
titleText.Font = Enum.Font.GothamBold
titleText.Text = "ECLIPSE HUB"
titleText.TextColor3 = THEME.AccentColor
titleText.TextSize = 22
titleText.TextXAlignment = Enum.TextXAlignment.Left
titleText.Parent = titleBar

-- Create the sidebar for categories
local sidebar = Instance.new("Frame")
sidebar.Name = "Sidebar"
sidebar.BackgroundColor3 = THEME.SecondaryBackground
sidebar.BorderSizePixel = 0
sidebar.Position = UDim2.new(0, 0, 0, 40)
sidebar.Size = UDim2.new(0, 150, 1, -40)
sidebar.Parent = mainFrame

-- Fix bottom left corner of sidebar
local sidebarCorner = Instance.new("UICorner")
sidebarCorner.CornerRadius = UDim.new(0, 10)
sidebarCorner.Parent = sidebar

-- Add a scroll frame for category buttons
local categoryScrollFrame = Instance.new("ScrollingFrame")
categoryScrollFrame.Name = "CategoryScrollFrame"
categoryScrollFrame.BackgroundTransparency = 1
categoryScrollFrame.Position = UDim2.new(0, 0, 0, 10)
categoryScrollFrame.Size = UDim2.new(1, 0, 1, -20)
categoryScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
categoryScrollFrame.ScrollBarThickness = 2
categoryScrollFrame.ScrollBarImageColor3 = THEME.AccentColor
categoryScrollFrame.BorderSizePixel = 0
categoryScrollFrame.Parent = sidebar

-- Add auto-layout for the category buttons
local categoryListLayout = Instance.new("UIListLayout")
categoryListLayout.Padding = UDim.new(0, 5)
categoryListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
categoryListLayout.SortOrder = Enum.SortOrder.LayoutOrder
categoryListLayout.Parent = categoryScrollFrame

-- Add padding for category buttons
local categoryPadding = Instance.new("UIPadding")
categoryPadding.PaddingTop = UDim.new(0, 5)
categoryPadding.PaddingRight = UDim.new(0, 5)
categoryPadding.PaddingBottom = UDim.new(0, 5)
categoryPadding.PaddingLeft = UDim.new(0, 5)
categoryPadding.Parent = categoryScrollFrame

-- Create the content area
local contentFrame = Instance.new("Frame")
contentFrame.Name = "ContentFrame"
contentFrame.BackgroundTransparency = 1
contentFrame.Position = UDim2.new(0, 150, 0, 40)
contentFrame.Size = UDim2.new(1, -150, 1, -40)
contentFrame.Parent = mainFrame

-- Add a close button
local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.AnchorPoint = Vector2.new(1, 0.5)
closeButton.BackgroundColor3 = THEME.SecondaryBackground
closeButton.BorderSizePixel = 0
closeButton.Position = UDim2.new(1, -10, 0.5, 0)
closeButton.Size = UDim2.new(0, 30, 0, 30)
closeButton.Font = Enum.Font.GothamBold
closeButton.Text = "X"
closeButton.TextColor3 = THEME.TextColor
closeButton.TextSize = 16
closeButton.Parent = titleBar

-- Add corner rounding to close button
local closeCorner = Instance.new("UICorner")
closeCorner.CornerRadius = UDim.new(0, 8)
closeCorner.Parent = closeButton

-- Minimize button
local minimizeButton = Instance.new("TextButton")
minimizeButton.Name = "MinimizeButton"
minimizeButton.AnchorPoint = Vector2.new(1, 0.5)
minimizeButton.BackgroundColor3 = THEME.SecondaryBackground
minimizeButton.BorderSizePixel = 0
minimizeButton.Position = UDim2.new(1, -50, 0.5, 0)
minimizeButton.Size = UDim2.new(0, 30, 0, 30)
minimizeButton.Font = Enum.Font.GothamBold
minimizeButton.Text = "-"
minimizeButton.TextColor3 = THEME.TextColor
minimizeButton.TextSize = 24
minimizeButton.Parent = titleBar

-- Add corner rounding to minimize button
local minimizeCorner = Instance.new("UICorner")
minimizeCorner.CornerRadius = UDim.new(0, 8)
minimizeCorner.Parent = minimizeButton

-- Add functionality to close button
closeButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = false
    minimizedUI.Visible = true
end)

-- Function to create module in a category
function EclipseUI:CreateModule(category, name, defaultState)
    -- Default state is off if not specified
    defaultState = defaultState or false

    -- Create module container
    local moduleFrame = Instance.new("Frame")
    moduleFrame.Name = name.."Module"
    moduleFrame.BackgroundColor3 = THEME.SecondaryBackground
    moduleFrame.BorderSizePixel = 0
    moduleFrame.Size = UDim2.new(1, 0, 0, 120) -- Taller than default to accommodate controls
    moduleFrame.Parent = category.Container

    -- Add corner rounding to module frame
    local moduleCorner = Instance.new("UICorner")
    moduleCorner.CornerRadius = UDim.new(0, 8)
    moduleCorner.Parent = moduleFrame

    -- Add module title
    local moduleTitle = Instance.new("TextLabel")
    moduleTitle.Name = "Title"
    moduleTitle.BackgroundTransparency = 1
    moduleTitle.Position = UDim2.new(0, 15, 0, 10)
    moduleTitle.Size = UDim2.new(1, -30, 0, 25)
    moduleTitle.Font = Enum.Font.GothamBold
    moduleTitle.Text = name
    moduleTitle.TextColor3 = THEME.AccentColor
    moduleTitle.TextSize = 18
    moduleTitle.TextXAlignment = Enum.TextXAlignment.Left
    moduleTitle.Parent = moduleFrame

    -- Create toggle button
    local toggleButton = Instance.new("TextButton")
    toggleButton.Name = "ToggleButton"
    toggleButton.AnchorPoint = Vector2.new(1, 0)
    toggleButton.BackgroundColor3 = defaultState and THEME.ToggleOn or THEME.ToggleOff
    toggleButton.BorderSizePixel = 0
    toggleButton.Position = UDim2.new(1, -15, 0, 10)
    toggleButton.Size = UDim2.new(0, 40, 0, 24)
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.Text = ""
    toggleButton.TextColor3 = THEME.TextColor
    toggleButton.TextSize = 14
    toggleButton.Parent = moduleFrame

    -- Add corner rounding to toggle button
    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 12)
    toggleCorner.Parent = toggleButton

    -- Create toggle circle indicator
    local toggleCircle = Instance.new("Frame")
    toggleCircle.Name = "Circle"
    toggleCircle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    toggleCircle.Position = defaultState and UDim2.new(1, -22, 0.5, 0) or UDim2.new(0, 2, 0.5, 0)
    toggleCircle.Size = UDim2.new(0, 20, 0, 20)
    toggleCircle.AnchorPoint = Vector2.new(0, 0.5)
    toggleCircle.Parent = toggleButton

    -- Add corner rounding to toggle circle
    local circleCorner = Instance.new("UICorner")
    circleCorner.CornerRadius = UDim.new(1, 0)
    circleCorner.Parent = toggleCircle

    -- Create content container for controls
    local contentContainer = Instance.new("Frame")
    contentContainer.Name = "Content"
    contentContainer.BackgroundTransparency = 1
    contentContainer.Position = UDim2.new(0, 15, 0, 45)
    contentContainer.Size = UDim2.new(1, -30, 1, -55)
    contentContainer.Parent = moduleFrame

    -- Add layout for controls
    local controlsLayout = Instance.new("UIListLayout")
    controlsLayout.Padding = UDim.new(0, 10)
    controlsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    controlsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    controlsLayout.Parent = contentContainer

    -- Add padding for controls
    local controlsPadding = Instance.new("UIPadding")
    controlsPadding.PaddingTop = UDim.new(0, 5)
    controlsPadding.PaddingRight = UDim.new(0, 5)
    controlsPadding.PaddingBottom = UDim.new(0, 5)
    controlsPadding.PaddingLeft = UDim.new(0, 5)
    controlsPadding.Parent = contentContainer

    -- Create module object
    local module = {
        Name = name,
        Frame = moduleFrame,
        Container = contentContainer,
        ToggleButton = toggleButton,
        ToggleCircle = toggleCircle,
        Enabled = defaultState,
        Controls = {},
        Value = defaultState
    }

    -- Add to category's modules
    table.insert(category.Modules, module)

    -- Add toggle functionality
    toggleButton.MouseButton1Click:Connect(function()
        module.Enabled = not module.Enabled
        module.Value = module.Enabled

        -- Update toggle appearance
        toggleButton.BackgroundColor3 = module.Enabled and THEME.ToggleOn or THEME.ToggleOff

        -- Animate toggle circle
        local newPosition = module.Enabled and UDim2.new(1, -22, 0.5, 0) or UDim2.new(0, 2, 0.5, 0)
        local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = tweenService:Create(toggleCircle, tweenInfo, {Position = newPosition})
        tween:Play()
    end)

    -- Auto-adjust module height based on controls
    controlsLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        moduleFrame.Size = UDim2.new(1, 0, 0, 45 + controlsLayout.AbsoluteContentSize.Y + 15)
    end)

    -- Add to EclipseUI modules table
    EclipseUI.Modules[name] = module

    return module
end

-- Function to create a slider control
function EclipseUI:CreateSlider(module, title, min, max, default, callback)
    -- Default values if not provided
    min = min or 0
    max = max or 100
    default = default or min

    -- Clamp default value to range
    default = math.clamp(default, min, max)

    -- Create slider container
    local sliderContainer = Instance.new("Frame")
    sliderContainer.Name = title.."SliderContainer"
    sliderContainer.BackgroundTransparency = 1
    sliderContainer.Size = UDim2.new(1, 0, 0, 50)
    sliderContainer.Parent = module.Container

    -- Create slider title
    local sliderTitle = Instance.new("TextLabel")
    sliderTitle.Name = "Title"
    sliderTitle.BackgroundTransparency = 1
    sliderTitle.Position = UDim2.new(0, 0, 0, 0)
    sliderTitle.Size = UDim2.new(1, 0, 0, 20)
    sliderTitle.Font = Enum.Font.GothamSemibold
    sliderTitle.Text = title
    sliderTitle.TextColor3 = THEME.TextColor
    sliderTitle.TextSize = 14
    sliderTitle.TextXAlignment = Enum.TextXAlignment.Left
    sliderTitle.Parent = sliderContainer

    -- Create slider value display
    local sliderValue = Instance.new("TextLabel")
    sliderValue.Name = "Value"
    sliderValue.BackgroundTransparency = 1
    sliderValue.Position = UDim2.new(1, -40, 0, 0)
    sliderValue.Size = UDim2.new(0, 40, 0, 20)
    sliderValue.Font = Enum.Font.GothamSemibold
    sliderValue.Text = tostring(default)
    sliderValue.TextColor3 = THEME.AccentColor
    sliderValue.TextSize = 14
    sliderValue.TextXAlignment = Enum.TextXAlignment.Right
    sliderValue.Parent = sliderContainer

    -- Create slider background
    local sliderBackground = Instance.new("Frame")
    sliderBackground.Name = "Background"
    sliderBackground.BackgroundColor3 = THEME.SliderBackground
    sliderBackground.BorderSizePixel = 0
    sliderBackground.Position = UDim2.new(0, 0, 0, 25)
    sliderBackground.Size = UDim2.new(1, 0, 0, 10)
    sliderBackground.Parent = sliderContainer

    -- Add corner rounding to slider background
    local backgroundCorner = Instance.new("UICorner")
    backgroundCorner.CornerRadius = UDim.new(0, 5)
    backgroundCorner.Parent = sliderBackground

    -- Create slider fill
    local sliderFill = Instance.new("Frame")
    sliderFill.Name = "Fill"
    sliderFill.BackgroundColor3 = THEME.AccentColor
    sliderFill.BorderSizePixel = 0
    sliderFill.Size = UDim2.new((default - min) / (max - min), 0, 1, 0)
    sliderFill.Parent = sliderBackground

    -- Add corner rounding to slider fill
    local fillCorner = Instance.new("UICorner")
    fillCorner.CornerRadius = UDim.new(0, 5)
    fillCorner.Parent = sliderFill

    -- Create slider thumb
    local sliderThumb = Instance.new("Frame")
    sliderThumb.Name = "Thumb"
    sliderThumb.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    sliderThumb.BorderSizePixel = 0
    sliderThumb.Position = UDim2.new((default - min) / (max - min), 0, 0.5, 0)
    sliderThumb.Size = UDim2.new(0, 16, 0, 16)
    sliderThumb.AnchorPoint = Vector2.new(0.5, 0.5)
    sliderThumb.Parent = sliderBackground

    -- Add corner rounding to slider thumb
    local thumbCorner = Instance.new("UICorner")
    thumbCorner.CornerRadius = UDim.new(1, 0)
    thumbCorner.Parent = sliderThumb

    -- Create slider control object
    local sliderControl = {
        Title = title,
        Container = sliderContainer,
        Background = sliderBackground,
        Fill = sliderFill,
        Thumb = sliderThumb,
        Value = default,
        Min = min,
        Max = max,
        Callback = callback
    }

    -- Add to module's controls
    table.insert(module.Controls, sliderControl)

    -- Add dragging functionality
    local isDragging = false

    sliderBackground.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            isDragging = true

            -- Calculate the new value based on mouse position
            local mousePos = input.Position.X
            local sliderPos = sliderBackground.AbsolutePosition.X
            local sliderWidth = sliderBackground.AbsoluteSize.X

            local relativePos = math.clamp((mousePos - sliderPos) / sliderWidth, 0, 1)
            local newValue = min + (max - min) * relativePos

            -- Round to integers if both min and max are integers
            if math.floor(min) == min and math.floor(max) == max then
                newValue = math.floor(newValue + 0.5)
            end

            -- Update the slider value
            sliderControl.Value = newValue
            sliderValue.Text = tostring(newValue)

            -- Update slider fill and thumb position
            sliderFill.Size = UDim2.new(relativePos, 0, 1, 0)
            sliderThumb.Position = UDim2.new(relativePos, 0, 0.5, 0)

            -- Call the callback function if provided
            if callback then
                callback(newValue)
            end
        end
    end)

    sliderBackground.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            isDragging = false
        end
    end)

    userInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and isDragging then
            -- Calculate the new value based on mouse position
            local mousePos = input.Position.X
            local sliderPos = sliderBackground.AbsolutePosition.X
            local sliderWidth = sliderBackground.AbsoluteSize.X

            local relativePos = math.clamp((mousePos - sliderPos) / sliderWidth, 0, 1)
            local newValue = min + (max - min) * relativePos

            -- Round to integers if both min and max are integers
            if math.floor(min) == min and math.floor(max) == max then
                newValue = math.floor(newValue + 0.5)
            end

            -- Update the slider value
            sliderControl.Value = newValue
            sliderValue.Text = tostring(newValue)

            -- Update slider fill and thumb position
            sliderFill.Size = UDim2.new(relativePos, 0, 1, 0)
            sliderThumb.Position = UDim2.new(relativePos, 0, 0.5, 0)

            -- Call the callback function if provided
            if callback then
                callback(newValue)
            end
        end
    end)

    return sliderControl
end

-- Function to create a switch/dropdown control
function EclipseUI:CreateSwitch(module, title, options, default, callback)
    -- Default values
    options = options or {"Option 1", "Option 2"}
    default = default or options[1]

    -- Create switch container
    local switchContainer = Instance.new("Frame")
    switchContainer.Name = title.."SwitchContainer"
    switchContainer.BackgroundTransparency = 1
    switchContainer.Size = UDim2.new(1, 0, 0, 50)
    switchContainer.Parent = module.Container

    -- Create switch title
    local switchTitle = Instance.new("TextLabel")
    switchTitle.Name = "Title"
    switchTitle.BackgroundTransparency = 1
    switchTitle.Position = UDim2.new(0, 0, 0, 0)
    switchTitle.Size = UDim2.new(1, 0, 0, 20)
    switchTitle.Font = Enum.Font.GothamSemibold
    switchTitle.Text = title
    switchTitle.TextColor3 = THEME.TextColor
    switchTitle.TextSize = 14
    switchTitle.TextXAlignment = Enum.TextXAlignment.Left
    switchTitle.Parent = switchContainer

    -- Create dropdown button
    local dropdownButton = Instance.new("TextButton")
    dropdownButton.Name = "DropdownButton"
    dropdownButton.BackgroundColor3 = THEME.SecondaryBackground
    dropdownButton.BorderSizePixel = 0
    dropdownButton.Position = UDim2.new(0, 0, 0, 25)
    dropdownButton.Size = UDim2.new(1, 0, 0, 30)
    dropdownButton.Font = Enum.Font.GothamSemibold
    dropdownButton.Text = default
    dropdownButton.TextColor3 = THEME.TextColor
    dropdownButton.TextSize = 14
    dropdownButton.Parent = switchContainer

    -- Add corner rounding to dropdown button
    local dropdownCorner = Instance.new("UICorner")
    dropdownCorner.CornerRadius = UDim.new(0, 5)
    dropdownCorner.Parent = dropdownButton

    -- Create dropdown icon
    local dropdownIcon = Instance.new("ImageLabel")
    dropdownIcon.Name = "Icon"
    dropdownIcon.BackgroundTransparency = 1
    dropdownIcon.Position = UDim2.new(1, -25, 0.5, 0)
    dropdownIcon.Size = UDim2.new(0, 15, 0, 15)
    dropdownIcon.AnchorPoint = Vector2.new(0.5, 0.5)
    dropdownIcon.Image = "rbxassetid://6031091004"
    dropdownIcon.ImageColor3 = THEME.AccentColor
    dropdownIcon.Parent = dropdownButton

    -- Create dropdown menu
    local dropdownMenu = Instance.new("Frame")
    dropdownMenu.Name = "DropdownMenu"
    dropdownMenu.BackgroundColor3 = THEME.SecondaryBackground
    dropdownMenu.BorderSizePixel = 0
    dropdownMenu.Position = UDim2.new(0, 0, 1, 5)
    dropdownMenu.Size = UDim2.new(1, 0, 0, #options * 30)
    dropdownMenu.Visible = false
    dropdownMenu.ZIndex = 10
    dropdownMenu.Parent = dropdownButton

    -- Add corner rounding to dropdown menu
    local menuCorner = Instance.new("UICorner")
    menuCorner.CornerRadius = UDim.new(0, 5)
    menuCorner.Parent = dropdownMenu

    -- Add layout for dropdown options
    local optionsLayout = Instance.new("UIListLayout")
    optionsLayout.Padding = UDim.new(0, 2)
    optionsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    optionsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    optionsLayout.Parent = dropdownMenu

    -- Create switch control object
    local switchControl = {
        Title = title,
        Container = switchContainer,
        Button = dropdownButton,
        Menu = dropdownMenu,
        Value = default,
        Options = options,
        Callback = callback
    }

    -- Add to module's controls
    table.insert(module.Controls, switchControl)

    -- Create option buttons
    for i, option in ipairs(options) do
        local optionButton = Instance.new("TextButton")
        optionButton.Name = option.."Option"
        optionButton.BackgroundColor3 = THEME.MainBackground
        optionButton.BorderSizePixel = 0
        optionButton.Size = UDim2.new(0.95, 0, 0, 25)
        optionButton.Font = Enum.Font.GothamSemibold
        optionButton.Text = option
        optionButton.TextColor3 = option == default and THEME.AccentColor or THEME.TextColor
        optionButton.TextSize = 14
        optionButton.ZIndex = 11
        optionButton.Parent = dropdownMenu

        -- Add corner rounding to option button
        local optionCorner = Instance.new("UICorner")
        optionCorner.CornerRadius = UDim.new(0, 5)
        optionCorner.Parent = optionButton

        -- Add click functionality
        optionButton.MouseButton1Click:Connect(function()
            -- Update selected option
            switchControl.Value = option
            dropdownButton.Text = option

            -- Update option colors
            for _, child in pairs(dropdownMenu:GetChildren()) do
                if child:IsA("TextButton") then
                    child.TextColor3 = child.Text == option and THEME.AccentColor or THEME.TextColor
                end
            end

            -- Hide the menu
            dropdownMenu.Visible = false

            -- Call the callback function if provided
            if callback then
                callback(option)
            end
        end)
    end

    -- Add click functionality to toggle menu
    dropdownButton.MouseButton1Click:Connect(function()
        dropdownMenu.Visible = not dropdownMenu.Visible
    end)

    -- Hide menu when clicking elsewhere
    userInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and dropdownMenu.Visible then
            local mousePos = userInputService:GetMouseLocation()
            local menuPos = dropdownMenu.AbsolutePosition
            local menuSize = dropdownMenu.AbsoluteSize

            if mousePos.X < menuPos.X or mousePos.X > menuPos.X + menuSize.X or
               mousePos.Y < menuPos.Y or mousePos.Y > menuPos.Y + menuSize.Y then
                if not (mousePos.X >= dropdownButton.AbsolutePosition.X and
                       mousePos.X <= dropdownButton.AbsolutePosition.X + dropdownButton.AbsoluteSize.X and
                       mousePos.Y >= dropdownButton.AbsolutePosition.Y and
                       mousePos.Y <= dropdownButton.AbsolutePosition.Y + dropdownButton.AbsoluteSize.Y) then
                    dropdownMenu.Visible = false
                end
            end
        end
    end)

    return switchControl
end

-- Function to create a keybind control
function EclipseUI:CreateKeybind(module, title, defaultKey, callback)
    -- Default values
    defaultKey = defaultKey or Enum.KeyCode.F

    -- Create keybind container
    local keybindContainer = Instance.new("Frame")
    keybindContainer.Name = title.."KeybindContainer"
    keybindContainer.BackgroundTransparency = 1
    keybindContainer.Size = UDim2.new(1, 0, 0, 50)
    keybindContainer.Parent = module.Container

    -- Create keybind title
    local keybindTitle = Instance.new("TextLabel")
    keybindTitle.Name = "Title"
    keybindTitle.BackgroundTransparency = 1
    keybindTitle.Position = UDim2.new(0, 0, 0, 0)
    keybindTitle.Size = UDim2.new(1, 0, 0, 20)
    keybindTitle.Font = Enum.Font.GothamSemibold
    keybindTitle.Text = title
    keybindTitle.TextColor3 = THEME.TextColor
    keybindTitle.TextSize = 14
    keybindTitle.TextXAlignment = Enum.TextXAlignment.Left
    keybindTitle.Parent = keybindContainer

    -- Create keybind button
    local keybindButton = Instance.new("TextButton")
    keybindButton.Name = "KeybindButton"
    keybindButton.BackgroundColor3 = THEME.SecondaryBackground
    keybindButton.BorderSizePixel = 0
    keybindButton.Position = UDim2.new(0, 0, 0, 25)
    keybindButton.Size = UDim2.new(1, 0, 0, 30)
    keybindButton.Font = Enum.Font.GothamSemibold
    keybindButton.Text = defaultKey.Name
    keybindButton.TextColor3 = THEME.TextColor
    keybindButton.TextSize = 14
    keybindButton.Parent = keybindContainer

    -- Add corner rounding to keybind button
    local keybindCorner = Instance.new("UICorner")
    keybindCorner.CornerRadius = UDim.new(0, 5)
    keybindCorner.Parent = keybindButton

    -- Create keybind control object
    local keybindControl = {
        Title = title,
        Container = keybindContainer,
        Button = keybindButton,
        Value = defaultKey,
        Listening = false,
        Callback = callback
    }

    -- Add to module's controls
    table.insert(module.Controls, keybindControl)

    -- Add click functionality to start listening for key press
    keybindButton.MouseButton1Click:Connect(function()
        keybindControl.Listening = true
        keybindButton.Text = "..."
        keybindButton.TextColor3 = THEME.AccentColor
    end)

    -- Listen for key press
    userInputService.InputBegan:Connect(function(input)
        if keybindControl.Listening and input.UserInputType == Enum.UserInputType.Keyboard then
            keybindControl.Value = input.KeyCode
            keybindButton.Text = input.KeyCode.Name
            keybindButton.TextColor3 = THEME.TextColor
            keybindControl.Listening = false

            -- Call the callback function if provided
            if callback then
                callback(input.KeyCode)
            end
        end
    end)

    return keybindControl
end

-- Create a small version of the UI that appears when the main UI is closed
local minimizedUI = Instance.new("Frame")
minimizedUI.Name = "MinimizedUI"
minimizedUI.BackgroundColor3 = THEME.MainBackground
minimizedUI.BorderSizePixel = 0
minimizedUI.Position = UDim2.new(0, 20, 0.5, 0)
minimizedUI.Size = UDim2.new(0, 50, 0, 50)
minimizedUI.Active = true
minimizedUI.Draggable = true
minimizedUI.Visible = false
minimizedUI.Parent = screenGui

-- Add corner rounding to the minimized UI
local minimizedCorner = Instance.new("UICorner")
minimizedCorner.CornerRadius = UDim.new(0, 10)
minimizedCorner.Parent = minimizedUI

-- Add a button to the minimized UI to show the main UI
local showButton = Instance.new("TextButton")
showButton.Name = "ShowButton"
showButton.BackgroundColor3 = THEME.AccentColor
showButton.BorderSizePixel = 0
showButton.Position = UDim2.new(0, 5, 0, 5)
showButton.Size = UDim2.new(1, -10, 1, -10)
showButton.Font = Enum.Font.GothamBold
showButton.Text = "EH"
showButton.TextColor3 = THEME.TextColor
showButton.TextSize = 20
showButton.Parent = minimizedUI

-- Add corner rounding to the show button
local showCorner = Instance.new("UICorner")
showCorner.CornerRadius = UDim.new(0, 8)
showCorner.Parent = showButton

-- Add functionality to the show button
showButton.MouseButton1Click:Connect(function()
    minimizedUI.Visible = false
    mainFrame.Visible = true
end)

-- When the close button is clicked, don't destroy the GUI, just hide it and show the minimized UI
closeButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = false
    minimizedUI.Visible = true
end)

-- Add functionality to minimize button
local isMinimized = false
minimizeButton.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized

    if isMinimized then
        mainFrame.Size = UDim2.new(0, 600, 0, 40)
        contentFrame.Visible = false
        sidebar.Visible = false
        minimizeButton.Text = "+"
    else
        mainFrame.Size = UDim2.new(0, 600, 0, 450)
        contentFrame.Visible = true
        sidebar.Visible = true
        minimizeButton.Text = "-"
    end
end)

-- Function to create categories
function EclipseUI:CreateCategory(name)
    -- Create category button
    local categoryButton = Instance.new("TextButton")
    categoryButton.Name = name.."Category"
    categoryButton.BackgroundColor3 = THEME.MainBackground
    categoryButton.BorderSizePixel = 0
    categoryButton.Size = UDim2.new(0.9, 0, 0, 40)
    categoryButton.Font = Enum.Font.GothamSemibold
    categoryButton.Text = name
    categoryButton.TextColor3 = THEME.TextColor
    categoryButton.TextSize = 16
    categoryButton.Parent = categoryScrollFrame

    -- Add corner rounding to category button
    local categoryCorner = Instance.new("UICorner")
    categoryCorner.CornerRadius = UDim.new(0, 8)
    categoryCorner.Parent = categoryButton

    -- Create a container for this category's modules
    local categoryContainer = Instance.new("ScrollingFrame")
    categoryContainer.Name = name.."Container"
    categoryContainer.BackgroundTransparency = 1
    categoryContainer.Size = UDim2.new(1, 0, 1, 0)
    categoryContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
    categoryContainer.ScrollBarThickness = 2
    categoryContainer.ScrollBarImageColor3 = THEME.AccentColor
    categoryContainer.BorderSizePixel = 0
    categoryContainer.Visible = false
    categoryContainer.Parent = contentFrame

    -- Add layout for category modules
    local moduleListLayout = Instance.new("UIListLayout")
    moduleListLayout.Padding = UDim.new(0, 10)
    moduleListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    moduleListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    moduleListLayout.Parent = categoryContainer

    -- Add padding for modules
    local modulePadding = Instance.new("UIPadding")
    modulePadding.PaddingTop = UDim.new(0, 10)
    modulePadding.PaddingRight = UDim.new(0, 15)
    modulePadding.PaddingBottom = UDim.new(0, 10)
    modulePadding.PaddingLeft = UDim.new(0, 15)
    modulePadding.Parent = categoryContainer

    -- Add this category to our categories table
    local category = {
        Name = name,
        Button = categoryButton,
        Container = categoryContainer,
        Modules = {}
    }

    -- Add to categories table
    table.insert(EclipseUI.Categories, category)

    -- Auto-adjust canvas size
    moduleListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        categoryContainer.CanvasSize = UDim2.new(0, 0, 0, moduleListLayout.AbsoluteContentSize.Y + 20)
    end)

    -- Add the selection logic
    categoryButton.MouseButton1Click:Connect(function()
        -- Hide all other categories
        for _, cat in pairs(EclipseUI.Categories) do
            cat.Container.Visible = false
            cat.Button.BackgroundColor3 = THEME.MainBackground
            cat.Button.TextColor3 = THEME.TextColor
        end

        -- Show this category
        categoryContainer.Visible = true
        categoryButton.BackgroundColor3 = THEME.AccentColor
        categoryButton.TextColor3 = Color3.fromRGB(255, 255, 255)

        EclipseUI.ActiveCategory = category
    end)

    -- If this is the first category, select it automatically
    if #EclipseUI.Categories == 1 then
        categoryButton.BackgroundColor3 = THEME.AccentColor
        categoryButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        categoryContainer.Visible = true
        EclipseUI.ActiveCategory = category
    end

    -- Auto-adjust the canvas size for categories
    categoryListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        categoryScrollFrame.CanvasSize = UDim2.new(0, 0, 0, categoryListLayout.AbsoluteContentSize.Y + 10)
    end)

    return category
end

-- Initialize categories
local fakeBalls = {}
local pullVectoredBalls = {}
local isCatching = false

-- Create categories
local catchingCategory = EclipseUI:CreateCategory("Catching")
local physicsCategory = EclipseUI:CreateCategory("Physics")
local autoCategory = EclipseUI:CreateCategory("Auto")
local throwingCategory = EclipseUI:CreateCategory("Throwing")
local playerCategory = EclipseUI:CreateCategory("Player")
local configsCategory = EclipseUI:CreateCategory("Configs")

-- Create modules for Catching category
local magnetsModule = EclipseUI:CreateModule(catchingCategory, "Magnets", false)
local magnetsTypeSwitch = EclipseUI:CreateSwitch(magnetsModule, "Type", {"Blatant", "Legit", "League"}, "Legit")
local magnetsCustomRadiusSlider = EclipseUI:CreateSlider(magnetsModule, "Radius", 0, 70, 20)
local showMagHitboxToggle = EclipseUI:CreateModule(catchingCategory, "Visualize Hitbox", false)

local pullVectorModule = EclipseUI:CreateModule(catchingCategory, "PullVector", false)
local pullVectorDistanceSlider = EclipseUI:CreateSlider(pullVectorModule, "Distance", 0, 100, 50)
local pullVectorTypeSwitch = EclipseUI:CreateSwitch(pullVectorModule, "Type", {"Glide", "Teleport"}, "Glide")
local pullVectorPowerSlider = EclipseUI:CreateSlider(pullVectorModule, "Power", 1, 5, 3)

-- Implement pull vector functionality
task.spawn(function()
    while true do
        task.wait()
        local ball = findClosestBall() if not ball then continue end
        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

        if not ball:FindFirstChildWhichIsA("Trail") then continue end
        if not character or not humanoidRootPart then continue end
        if not pullVectorModule.Value then continue end
        if pullVectoredBalls[ball] then continue end
        if ball.Anchored then continue end

        local distance = (humanoidRootPart.Position - ball.Position).Magnitude
        if distance > pullVectorDistanceSlider.Value then continue end

        local direction = (ball.Position - humanoidRootPart.Position).Unit

        if pullVectorTypeSwitch.Value == "Teleport" then
            pullVectoredBalls[ball] = true
            local distance = 10 + ((pullVectorPowerSlider.Value - 1) * 5)
            humanoidRootPart.CFrame += direction * distance
        else
            humanoidRootPart.AssemblyLinearVelocity = direction * pullVectorPowerSlider.Value * 25
        end
    end
end)

-- Create modules for Physics category
local quickTPModule = EclipseUI:CreateModule(physicsCategory, "QuickTP", false)
local quickTPSpeedSlider = EclipseUI:CreateSlider(quickTPModule, "Speed", 1, 5, 3)
local quickTPBindKeybind = EclipseUI:CreateKeybind(quickTPModule, "Keybind", Enum.KeyCode.F)

local clickTackleAimbotModule = EclipseUI:CreateModule(physicsCategory, "ClickTackleAimbot", false)
local clickTackleAimbotDistanceSlider = EclipseUI:CreateSlider(clickTackleAimbotModule, "Distance", 0, 15, 8)

local antiJamModule = EclipseUI:CreateModule(physicsCategory, "AntiJam", false)
local antiBlockModule = EclipseUI:CreateModule(physicsCategory, "AntiBlock", false)
local visualiseBallPathModule = EclipseUI:CreateModule(physicsCategory, "VisualiseBallPath", false)
local noJumpCooldownModule = EclipseUI:CreateModule(physicsCategory, "NoJumpCooldown", false)
local noFreezeModule = EclipseUI:CreateModule(physicsCategory, "NoFreeze", false)

local optimalJumpPredictionsModule = EclipseUI:CreateModule(physicsCategory, "OptimalJump", false)
local optimalJumpTypeSwitch = EclipseUI:CreateSwitch(optimalJumpPredictionsModule, "Type", {"Jump", "Dive"}, "Jump")

local noBallTrailModule = EclipseUI:CreateModule(physicsCategory, "NoBallTrail", false)
local bigHeadModule = EclipseUI:CreateModule(physicsCategory, "BigHead", false)
local bigHeadSizeSlider = EclipseUI:CreateSlider(bigHeadModule, "Size", 1, 5, 3)

-- If not on practice mode and firetouchinterest is available
if firetouchinterest and not IS_SOLARA then
    local tackleExtenderModule = EclipseUI:CreateModule(physicsCategory, "TackleExtender", false)
    local tackleExtenderRadiusSlider = EclipseUI:CreateSlider(tackleExtenderModule, "Radius", 0, 10, 5)
end

-- If on practice mode (AC_BYPASS is true)
if AC_BYPASS then
    local blockExtenderModule = EclipseUI:CreateModule(physicsCategory, "BlockExtender", false)
    local blockExtenderRangeSlider = EclipseUI:CreateSlider(blockExtenderModule, "Range", 1, 20, 10)
    local blockExtenderRangeTransparencySlider = EclipseUI:CreateSlider(blockExtenderModule, "Transparency", 0, 1, 1)

    local flyModule = EclipseUI:CreateModule(physicsCategory, "Fly", false)
    local flySpeedSlider = EclipseUI:CreateSlider(flyModule, "Speed", 1, IS_PRACTICE and 20 or 5, 3)
end

-- Create modules for Player category
local angleAssistModule = EclipseUI:CreateModule(playerCategory, "AngleAssist", false)
local angleAssistJPSlider = EclipseUI:CreateSlider(angleAssistModule, "JP", 50, 70, 60)

local speedModule = EclipseUI:CreateModule(playerCategory, "Speed", false)
local speedValueSlider = EclipseUI:CreateSlider(speedModule, "Speed", 20, 23, 21)

local jumpPowerModule = EclipseUI:CreateModule(playerCategory, "JumpPower", false)
local jumpPowerValueSlider = EclipseUI:CreateSlider(jumpPowerModule, "Power", 50, 70, 60)

-- Create modules for Auto category
local autoCapModule = EclipseUI:CreateModule(autoCategory, "AutoCap", false)

-- Create modules for Throwing category
local qbAimbotModule = EclipseUI:CreateModule(throwingCategory, "QB Aimbot", false)
EclipseUI:CreateSwitch(qbAimbotModule, "Status", {"Coming Soon"}, "Coming Soon")

-- Create modules for Configs category
local saveConfigModule = EclipseUI:CreateModule(configsCategory, "Save Config", false)
local loadConfigModule = EclipseUI:CreateModule(configsCategory, "Load Config", false)

-- Implement the catching functionality
local velocity = {}

local function onCharacterCatching(character)
    local arm = character:WaitForChild('Left Arm')

    arm.ChildAdded:Connect(function(child)
        if not child:IsA("Weld") then return end
        isCatching = true
        task.wait(1.7)
        isCatching = false
    end)
end

workspace.ChildAdded:Connect(function(ball)
    if ball.Name ~= "Football" then return end
    if not ball:IsA("BasePart") then return end
    task.wait()

    local lastPosition = ball.Position
    local lastCheck = os.clock()
    local initalVelocity = ball.AssemblyLinearVelocity

    if (IS_SOLARA) and ball:FindFirstChildWhichIsA("Trail") and not ball.Anchored and camera.CameraSubject ~= ball then
        local fakeBall = ball:Clone()
        fakeBall.Name = "FFootball"
        fakeBall.Parent = workspace
        fakeBall.Anchored = true
        fakeBall.CanCollide = false
        fakeBall:FindFirstChildWhichIsA('PointLight'):Destroy()
        ball.Transparency = 1
        local spiralDegrees = 0
        fakeBalls[ball] = fakeBall
        task.spawn(function()
            while ball.Parent == workspace do
                local dt = runService.Heartbeat:Wait()
                spiralDegrees += 1500 * dt
                initalVelocity += Vector3.new(0, -28 * dt, 0)
                fakeBall.Position += initalVelocity * dt
                fakeBall.CFrame = CFrame.lookAt(fakeBall.Position, fakeBall.Position + initalVelocity) * CFrame.Angles(math.rad(90), math.rad(spiralDegrees), 0)

                if ball:FindFirstChildWhichIsA("Trail") then
                    ball:FindFirstChildWhichIsA("Trail").Enabled = noBallTrailModule.Value
                end
            end
            fakeBall:Destroy()
        end)
    end

    while ball.Parent do
        task.wait(0.1)

        local t = (os.clock() - lastCheck)
        velocity[ball] = (ball.Position - lastPosition) / t

        lastCheck = os.clock()
        lastPosition = ball.Position
    end
end)

-- Implement magnets functionality
task.spawn(function()
    while true do
        task.wait(1/60)
        local ball = findClosestBall(); if not ball then part.Parent = nil continue end
        local character = player.Character

        if not character then continue end

        local catchPart = getNearestPartToPartFromParts(ball, {character:FindFirstChild("CatchLeft"), character:FindFirstChild("CatchRight")})

        if not catchPart then continue end
        if not velocity[ball] then continue end
        if not magnetsModule.Value then
            part.Parent = nil
            continue
        end

        local magnetsTypeValue = magnetsTypeSwitch.Value

        if magnetsTypeValue == "League" then
            local predictedPosition = (fakeBalls[ball] or ball).Position + (velocity[ball] * ping)
            local distance = (catchPart.Position - predictedPosition).Magnitude

            -- Position the hitbox directly at the ball position, not in front of it
            part.Position = (fakeBalls[ball] or ball).Position
            part.Size = Vector3.new(magnetsCustomRadiusSlider.Value, magnetsCustomRadiusSlider.Value, magnetsCustomRadiusSlider.Value)
            part.Parent = showMagHitboxToggle.Value and workspace or nil
            part.Color = THEME.AccentColor -- Light blue color
            part.Material = Enum.Material.ForceField -- Use ForceField for smoother edge appearance
            part.Transparency = 0.5 -- Adjust transparency to make it slightly more visible

            if distance > magnetsCustomRadiusSlider.Value then continue end

            firetouchinterest(catchPart, ball, 0)
            firetouchinterest(catchPart, ball, 1)
        else
            local distance = (catchPart.Position - ball.Position).Magnitude
            local radius = (magnetsTypeValue == "Blatant" and 50 or 6)

            -- Position the hitbox directly at the ball position
            part.Position = (fakeBalls[ball] or ball).Position
            part.Size = Vector3.new(radius, radius, radius)
            part.Parent = showMagHitboxToggle.Value and workspace or nil
            part.Color = THEME.AccentColor -- Light blue color
            part.Material = Enum.Material.ForceField -- Use ForceField for smoother edge appearance
            part.Transparency = 0.5 -- Adjust transparency to make it slightly more visible

            if not isCatching and IS_SOLARA then continue end

            if distance < radius then
                firetouchinterest(catchPart, ball, 0)
                firetouchinterest(catchPart, ball, 1)
            end
        end
    end
end)

-- Implement quick teleport functionality
local quickTPCooldown = os.clock()

userInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode ~= quickTPBindKeybind.Value then return end

    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    local humanoid = character and character:FindFirstChild("Humanoid")

    if not quickTPModule.Value then return end
    if not character or not humanoidRootPart or not humanoid then return end
    if (os.clock() - quickTPCooldown) < 0.1 then return end

    local speed = 2 + (quickTPSpeedSlider.Value / 4)

    humanoidRootPart.CFrame += humanoid.MoveDirection * speed
    quickTPCooldown = os.clock()
end)

-- Implement click tackle aimbot
mouse.Button1Down:Connect(function()
    if not clickTackleAimbotModule.Value then return end

    local possessor = findPossessor()
    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not character or not humanoidRootPart then return end
    if not possessor then return end

    local distance = (possessor.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
    if distance > clickTackleAimbotDistanceSlider.Value then return end

    humanoidRootPart.CFrame = possessor.HumanoidRootPart.CFrame
end)

-- Implement character physics changes
local function onCharacterPhysics(char)
    local humanoid = char:WaitForChild("Humanoid")

    char.DescendantAdded:Connect(function(v)
        task.wait()
        if v.Name:match("FFmover") and antiBlockModule.Value then
            v:Destroy()
        end
    end)

    task.spawn(function()
        while true do
            task.wait()
            if noJumpCooldownModule.Value then
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
            end

            local torso = char:FindFirstChild("Torso")
            local head = char:FindFirstChild("Head")

            if not torso or not head then return end

            if humanoid:GetState() == Enum.HumanoidStateType.Running and values.Status.Value == "InPlay" then
                torso.CanCollide = not antiJamModule.Value
                head.CanCollide = not antiJamModule.Value
            else
                torso.CanCollide = true
                head.CanCollide = true
            end
        end
    end)
end

-- Apply character functions to current character and future characters
onCharacterCatching(player.Character or player.CharacterAdded:Wait())
onCharacterPhysics(player.Character or player.CharacterAdded:Wait())

player.CharacterAdded:Connect(onCharacterCatching)
player.CharacterAdded:Connect(onCharacterPhysics)

-- Implement speed modifications
runService:BindToRenderStep("walkSpeed", Enum.RenderPriority.Character.Value, function()
    local character = player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")

    if not character or not humanoid then return end
    if humanoid:GetState() ~= Enum.HumanoidStateType.Running then return end
    if humanoid.WalkSpeed == 0 and not noFreezeModule.Value then return end
    if not character:FindFirstChild("HumanoidRootPart") then return end

    local moveDirection = ((os.clock() - (moveToUsing[#moveToUsing] or 0)) < 0.5 and (humanoid.WalkToPoint - character.HumanoidRootPart.Position).Unit) or (humanoid.MoveDirection)
    local currentVel = character.HumanoidRootPart.AssemblyLinearVelocity

    if speedModule.Value or noFreezeModule.Value then
        local speedVal = speedModule.Value and (speedValueSlider.Value > 20 and speedValueSlider.Value) or 20
        character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(moveDirection.X * speedVal, currentVel.Y, moveDirection.Z * speedVal)
    end
end)

-- Notify on load
local notificationFrame = Instance.new("Frame")
notificationFrame.Name = "Notification"
notificationFrame.BackgroundColor3 = THEME.MainBackground
notificationFrame.BorderSizePixel = 0
notificationFrame.Position = UDim2.new(0.5, -150, 0, -40)
notificationFrame.Size = UDim2.new(0, 300, 0, 40)
notificationFrame.Parent = screenGui

-- Add corner rounding
local notificationCorner = Instance.new("UICorner")
notificationCorner.CornerRadius = UDim.new(0, 10)
notificationCorner.Parent = notificationFrame

-- Add notification text
local notificationText = Instance.new("TextLabel")
notificationText.Name = "Text"
notificationText.BackgroundTransparency = 1
notificationText.Position = UDim2.new(0, 0, 0, 0)
notificationText.Size = UDim2.new(1, 0, 1, 0)
notificationText.Font = Enum.Font.GothamSemibold
notificationText.Text = "Eclipse Hub Loaded!"
notificationText.TextColor3 = THEME.AccentColor
notificationText.TextSize = 16
notificationText.Parent = notificationFrame

-- Show and hide notification with animation
tweenService:Create(notificationFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(0.5, -150, 0, 20)}):Play()

task.delay(3, function()
    tweenService:Create(notificationFrame, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = UDim2.new(0.5, -150, 0, -40)}):Play()
    task.delay(0.5, function()
        notificationFrame:Destroy()
    end)
end)

-- Add config saving and loading functionality
-- Function to save config
local function saveConfig(configName)
    local config = {}

    -- Save all module states
    for name, module in pairs(EclipseUI.Modules) do
        config[name] = {
            Enabled = module.Value
        }

        -- Save all control values
        if module.Controls then
            config[name].Controls = {}
            for _, control in pairs(module.Controls) do
                config[name].Controls[control.Title] = control.Value
            end
        end
    end

    -- Save to file
    writefile("eclipsehub/"..configName..".json", httpService:JSONEncode(config))
end

-- Function to load config
local function loadConfig(configName)
    if not isfile("eclipsehub/"..configName..".json") then return false end

    local config = httpService:JSONDecode(readfile("eclipsehub/"..configName..".json"))

    -- Load all module states
    for name, data in pairs(config) do
        local module = EclipseUI.Modules[name]
        if module then
            -- Set module state
            module.Value = data.Enabled
            module.Enabled = data.Enabled
            module.ToggleButton.BackgroundColor3 = data.Enabled and THEME.ToggleOn or THEME.ToggleOff

            -- Update toggle circle position
            local newPosition = data.Enabled and UDim2.new(1, -22, 0.5, 0) or UDim2.new(0, 2, 0.5, 0)
            module.ToggleCircle.Position = newPosition

            -- Load all control values
            if data.Controls and module.Controls then
                for title, value in pairs(data.Controls) do
                    for _, control in pairs(module.Controls) do
                        if control.Title == title then
                            control.Value = value

                            -- Update UI based on control type
                            if control.Button and control.Button:IsA("TextButton") then
                                control.Button.Text = tostring(value)
                            elseif control.Fill and control.Thumb then
                                -- Update slider
                                local relativePos = (value - control.Min) / (control.Max - control.Min)
                                control.Fill.Size = UDim2.new(relativePos, 0, 1, 0)
                                control.Thumb.Position = UDim2.new(relativePos, 0, 0.5, 0)

                                -- Update value display if present
                                for _, child in pairs(control.Container:GetChildren()) do
                                    if child.Name == "Value" and child:IsA("TextLabel") then
                                        child.Text = tostring(value)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    return true
end

-- Create config UI for saving and loading
local configNameBox
local configAction = nil

local function createConfigUI()
    -- Create Config UI Frame
    local configFrame = Instance.new("Frame")
    configFrame.Name = "ConfigFrame"
    configFrame.BackgroundColor3 = THEME.SecondaryBackground
    configFrame.BorderSizePixel = 0
    configFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
    configFrame.Size = UDim2.new(0, 300, 0, 150)
    configFrame.Visible = false
    configFrame.ZIndex = 100
    configFrame.Parent = screenGui

    -- Add corner rounding
    local configCorner = Instance.new("UICorner")
    configCorner.CornerRadius = UDim.new(0, 10)
    configCorner.Parent = configFrame

    -- Add title
    local configTitle = Instance.new("TextLabel")
    configTitle.Name = "Title"
    configTitle.BackgroundTransparency = 1
    configTitle.Position = UDim2.new(0, 0, 0, 10)
    configTitle.Size = UDim2.new(1, 0, 0, 30)
    configTitle.Font = Enum.Font.GothamBold
    configTitle.Text = "Config"
    configTitle.TextColor3 = THEME.AccentColor
    configTitle.TextSize = 18
    configTitle.ZIndex = 101
    configTitle.Parent = configFrame

    -- Add text input box
    configNameBox = Instance.new("TextBox")
    configNameBox.Name = "ConfigName"
    configNameBox.BackgroundColor3 = THEME.MainBackground
    configNameBox.BorderSizePixel = 0
    configNameBox.Position = UDim2.new(0.5, -125, 0, 60)
    configNameBox.Size = UDim2.new(0, 250, 0, 30)
    configNameBox.Font = Enum.Font.GothamSemibold
    configNameBox.PlaceholderText = "Enter config name..."
    configNameBox.Text = ""
    configNameBox.TextColor3 = THEME.TextColor
    configNameBox.TextSize = 14
    configNameBox.ZIndex = 101
    configNameBox.Parent = configFrame

    -- Add corner rounding to text box
    local textBoxCorner = Instance.new("UICorner")
    textBoxCorner.CornerRadius = UDim.new(0, 5)
    textBoxCorner.Parent = configNameBox

    -- Add confirm button
    local confirmButton = Instance.new("TextButton")
    confirmButton.Name = "ConfirmButton"
    confirmButton.BackgroundColor3 = THEME.AccentColor
    confirmButton.BorderSizePixel = 0
    confirmButton.Position = UDim2.new(0.5, -75, 0, 105)
    confirmButton.Size = UDim2.new(0, 150, 0, 30)
    confirmButton.Font = Enum.Font.GothamSemibold
    confirmButton.Text = "Confirm"
    confirmButton.TextColor3 = THEME.TextColor
    confirmButton.TextSize = 14
    confirmButton.ZIndex = 101
    confirmButton.Parent = configFrame

    -- Add corner rounding to confirm button
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 5)
    buttonCorner.Parent = confirmButton

    -- Add button functionality
    confirmButton.MouseButton1Click:Connect(function()
        local configName = configNameBox.Text
        if configName == "" then return end

        if configAction == "save" then
            saveConfig(configName)
        elseif configAction == "load" then
            loadConfig(configName)
        end

        configFrame.Visible = false
        configNameBox.Text = ""
    end)

    return configFrame
end

local configUI = createConfigUI()

-- Add callbacks for save and load config buttons
saveConfigModule.ToggleButton.MouseButton1Click:Connect(function()
    if not saveConfigModule.Value then return end
    configAction = "save"
    configUI.Title.Text = "Save Config"
    configUI.Visible = true
    saveConfigModule.Value = false
    saveConfigModule.Enabled = false
    saveConfigModule.ToggleButton.BackgroundColor3 = THEME.ToggleOff
    saveConfigModule.ToggleCircle.Position = UDim2.new(0, 2, 0.5, 0)
end)

loadConfigModule.ToggleButton.MouseButton1Click:Connect(function()
    if not loadConfigModule.Value then return end
    configAction = "load"
    configUI.Title.Text = "Load Config"
    configUI.Visible = true
    loadConfigModule.Value = false
    loadConfigModule.Enabled = false
    loadConfigModule.ToggleButton.BackgroundColor3 = THEME.ToggleOff
    loadConfigModule.ToggleCircle.Position = UDim2.new(0, 2, 0.5, 0)
end)
