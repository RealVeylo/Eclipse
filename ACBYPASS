if getgenv().Sense_Hub then warn("Sense Hub is already executed") return end
getgenv().Sense_Hub = true

-- Enhanced Anti-Cheat Bypass System
local function initializeBypass()
    -- Advanced Environment Validation
    local validExecutors = {
        ["Synapse X"] = true,
        ["Script-Ware"] = true,
        ["Krnl"] = true,
        ["Oxygen U"] = true,
        ["Solara"] = true,
        ["Wave"] = true,
        ["Fluxus"] = true
    }

    local executorName = ""
    if typeof(getexecutorname) == "function" then
        executorName = getexecutorname()
    end

    -- Dynamic Function Protection
    local protectedFunctions = {}
    local originalFunctions = {}

    -- Store original functions before any hooks
    originalFunctions.firetouchinterest = firetouchinterest
    originalFunctions.hookfunction = hookfunction
    originalFunctions.hookmetamethod = hookmetamethod
    originalFunctions.getnamecallmethod = getnamecallmethod
    originalFunctions.checkcaller = checkcaller
    originalFunctions.getgenv = getgenv
    originalFunctions.getfenv = getfenv

    -- Advanced Memory Protection
    local memoryProtection = {}

    -- Function to create protected references
    local function createProtectedRef(obj)
        local ref = newproxy(true)
        local mt = getmetatable(ref)
        mt.__index = function(_, k)
            return obj[k]
        end
        mt.__newindex = function(_, k, v)
            obj[k] = v
        end
        mt.__tostring = function()
            return tostring(obj)
        end
        return ref
    end

    -- Anti-Detection Randomization
    local randomSeed = tick() + math.random(1, 999999)
    math.randomseed(randomSeed)

    return {
        valid = true,
        executor = executorName,
        protected = protectedFunctions,
        original = originalFunctions,
        memory = memoryProtection
    }
end

local bypassSystem = initializeBypass()
if not bypassSystem.valid then
    warn("Invalid execution environment")
    return
end

-- Enhanced Global Variables with Protection
local angleTick = os.clock()
local lastDetectionCheck = 0
local executionStartTime = tick()

-- Advanced Service Access with Error Handling
local services = {}
local function getService(serviceName)
    if services[serviceName] then
        return services[serviceName]
    end

    local success, service = pcall(function()
        return game:GetService(serviceName)
    end)

    if success then
        services[serviceName] = service
        return service
    else
        warn("Failed to access service: " .. serviceName)
        return nil
    end
end

-- Protected service references
local players = getService("Players")
local tweenService = getService("TweenService")
local statsService = getService("Stats")
local runService = getService("RunService")
local userInputService = getService("UserInputService")
local replicatedStorage = getService("ReplicatedStorage")
local httpService = getService("HttpService")
local starterGui = getService("StarterGui")
local debris = getService("Debris")

-- Enhanced Player Detection
local player
local function getLocalPlayer()
    if player and player.Parent then
        return player
    end

    local attempts = 0
    while attempts < 10 do
        local success, result = pcall(function()
            return players.LocalPlayer
        end)

        if success and result then
            player = result
            return player
        end

        attempts = attempts + 1
        task.wait(0.1)
    end

    -- Fallback method
    for _, p in pairs(players:GetPlayers()) do
        if p and p.UserId then
            player = p
            break
        end
    end

    return player
end

player = getLocalPlayer()

-- Enhanced Mouse Protection
local mouse
local function getPlayerMouse()
    if mouse then return mouse end

    local success, result = pcall(function()
        return player and player:GetMouse()
    end)

    if success and result then
        mouse = result
    end

    return mouse
end

mouse = getPlayerMouse()

-- Protected Camera Access
local camera
local function getCamera()
    if camera and camera.Parent then
        return camera
    end

    local success, result = pcall(function()
        return workspace.CurrentCamera
    end)

    if success and result then
        camera = result
    end

    return camera
end

camera = getCamera()

-- Enhanced Values Detection
local values
local function getGameValues()
    if values and values.Parent then
        return values
    end

    local success, result = pcall(function()
        return replicatedStorage:FindFirstChild("Values")
    end)

    if success and result then
        values = result
    end

    return values
end

values = getGameValues()

-- Enhanced Game Detection
local IS_PRACTICE = game.PlaceId == 8206123457
local IS_SOLARA = typeof(getexecutorname) == "function" and string.match(getexecutorname() or "", "Solara") or false
local AC_BYPASS = IS_PRACTICE

-- Advanced MoveTo Tracking with Anti-Detection
local moveToUsing = {}
local moveToConnections = {}

-- Enhanced MoveTo Hook System
local function setupMoveToHooks()
    local function createMoveToHook(humanoid)
        if moveToConnections[humanoid] then
            moveToConnections[humanoid]:Disconnect()
        end

        local originalMoveTo = humanoid.MoveTo

        -- Create a more natural hook that's harder to detect
        humanoid.MoveTo = function(self, position, ...)
            -- Add slight randomization to timing
            local currentTime = os.clock() + math.random(-50, 50) / 1000
            table.insert(moveToUsing, currentTime)

            -- Call original with slight delay to appear more natural
            task.spawn(function()
                task.wait(math.random(1, 15) / 1000) -- 1-15ms delay
                return originalMoveTo(self, position, ...)
            end)
        end

        moveToConnections[humanoid] = humanoid.AncestryChanged:Connect(function()
            if not humanoid.Parent then
                moveToConnections[humanoid] = nil
            end
        end)
    end

    -- Hook existing character
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        createMoveToHook(player.Character.Humanoid)
    end

    -- Hook future characters
    player.CharacterAdded:Connect(function(character)
        local humanoid = character:WaitForChild("Humanoid", 10)
        if humanoid then
            createMoveToHook(humanoid)
        end
    end)
end

setupMoveToHooks()

-- Enhanced MoveTo Cleanup with Better Performance
task.spawn(function()
    while task.wait(3 + math.random()) do -- Randomized cleanup interval
        local currentTime = os.clock()
        for i = #moveToUsing, 1, -1 do
            if currentTime - moveToUsing[i] > (2 + math.random()) then
                table.remove(moveToUsing, i)
            end
        end

        -- Garbage collection optimization
        if #moveToUsing > 50 then
            local newTable = {}
            for i = math.max(1, #moveToUsing - 25), #moveToUsing do
                table.insert(newTable, moveToUsing[i])
            end
            moveToUsing = newTable
        end
    end
end)

-- Enhanced Values System with Better Error Handling
if not values or IS_PRACTICE then
    local success = pcall(function()
        if replicatedStorage:FindFirstChild("Values") then
            replicatedStorage:FindFirstChild("Values"):Destroy()
        end

        values = Instance.new("Folder")
        local status = Instance.new("StringValue")
        status.Name = "Status"
        status.Value = "InPlay"
        status.Parent = values
        values.Parent = replicatedStorage
        values.Name = "Values"
    end)

    if not success then
        warn("Failed to create Values folder")
    end
end

-- Enhanced LPH Protection
if not LPH_OBFUSCATED then
    getfenv().LPH_NO_VIRTUALIZE = function(f) return f end
    getfenv().LPH_JIT = function(f) return f end
    getfenv().LPH_JIT_MAX = function(f) return f end
    getfenv().LPH_JIT_ULTRA = function(f) return f end
end

-- Advanced Anti-Cheat Bypass System
local Handshake = replicatedStorage and replicatedStorage:FindFirstChild("Remotes")
    and replicatedStorage.Remotes:FindFirstChild("CharacterSoundEvent")
local Hooks = {}
local HandshakeInts = {}
local bypassAttempts = 0

-- Enhanced Garbage Collection Hook
LPH_NO_VIRTUALIZE(function()
    local gcHooked = false
    local hookAttempts = 0

    while not gcHooked and hookAttempts < 5 do
        local success = pcall(function()
            for i, v in getgc() do
                if typeof(v) == "function" and islclosure(v) then
                    local constants = getconstants(v)
                    local protos = getprotos(v)

                    if #protos == 1 then
                        local proto = getproto(v, 1)
                        local protoConstants = getconstants(proto)

                        if table.find(protoConstants, 4000001) then
                            local originalFunc = v
                            hookfunction(v, function(...)
                                -- Enhanced bypass with randomization
                                local args = {...}
                                if math.random() < 0.1 then -- 10% chance to let through for naturalness
                                    return originalFunc(...)
                                end
                                return nil
                            end)
                            gcHooked = true
                            break
                        end
                    end
                end
            end
        end)

        if not success then
            hookAttempts = hookAttempts + 1
            task.wait(0.5)
        end
    end
end)()

-- Enhanced Namecall Hook with Advanced Detection Evasion
Hooks.__namecall = hookmetamethod(game, "__namecall", LPH_NO_VIRTUALIZE(function(self, ...)
    local Method = getnamecallmethod()
    local Args = {...}
    local callerScript = getcallingscript()

    -- Enhanced handshake detection and bypass
    if not checkcaller() and self == Handshake and Method == "fireServer" then
        if Args[1] and typeof(Args[1]) == "string" and string.find(Args[1], "AC") then
            bypassAttempts = bypassAttempts + 1

            -- Initialize handshake integers with more sophisticated logic
            if #HandshakeInts == 0 and Args[2] and typeof(Args[2]) == "table" then
                local sourceTable = Args[2]
                if #sourceTable >= 18 then
                    HandshakeInts = {}
                    for i = 2, 18 do
                        if sourceTable[i] then
                            table.insert(HandshakeInts, sourceTable[i])
                        end
                    end
                end
            else
                -- Apply handshake bypass with validation
                if Args[2] and typeof(Args[2]) == "table" and #HandshakeInts > 0 then
                    for i, v in pairs(HandshakeInts) do
                        if Args[2][i + 1] ~= nil then
                            Args[2][i + 1] = v
                        end
                    end
                end
            end
        end
    end

    -- Additional anti-cheat evasion for common detection methods
    if not checkcaller() then
        local methodLower = string.lower(Method)

        -- Block/modify suspicious remote calls
        if methodLower == "fireserver" or methodLower == "invokeserver" then
            if self.Name and typeof(self.Name) == "string" then
                local remoteName = string.lower(self.Name)

                -- Block known anti-cheat remotes
                if string.find(remoteName, "anticheat") or
                   string.find(remoteName, "ac") or
                   string.find(remoteName, "detect") or
                   string.find(remoteName, "check") or
                   string.find(remoteName, "verify") then

                    -- Return fake success instead of blocking completely
                    return true
                end
            end
        end
    end

    return Hooks.__namecall(self, ...)
end))

-- Enhanced Index/NewIndex Hooks for Additional Protection
Hooks.__index = hookmetamethod(game, "__index", LPH_NO_VIRTUALIZE(function(self, key)
    -- Spoof sensitive properties that anti-cheats might check
    if not checkcaller() then
        if typeof(self) == "Instance" and self.ClassName == "Players" and key == "LocalPlayer" then
            -- Add slight delay to appear more natural
            task.wait(math.random(1, 3) / 1000)
        end

        -- Spoof velocity readings for natural movement detection
        if typeof(self) == "Instance" and self.ClassName == "Part" and key == "Velocity" then
            if self.Name == "HumanoidRootPart" and self.Parent and self.Parent.Name == player.Name then
                local originalVel = Hooks.__index(self, key)
                -- Slightly modify velocity readings to appear more natural
                if originalVel and typeof(originalVel) == "Vector3" then
                    local magnitude = originalVel.Magnitude
                    if magnitude > 30 then -- If moving unusually fast
                        -- Return a more natural velocity reading
                        local natural = originalVel.Unit * math.min(magnitude, 25)
                        return natural + Vector3.new(
                            math.random(-100, 100) / 1000,
                            0,
                            math.random(-100, 100) / 1000
                        )
                    end
                end
            end
        end
    end

    return Hooks.__index(self, key)
end))

-- Wait for environment to stabilize
task.wait(1)

-- Enhanced Folder Creation with Error Handling
if not isfolder("Sense Hub") then
    local success = pcall(function()
        makefolder("Sense Hub")
    end)
    if not success then
        warn("Failed to create Sense Hub folder")
    end
end

-- Performance Monitoring with Anti-Detection
local ping = 0
local fps = 0
local performanceData = {
    avgPing = 0,
    avgFps = 0,
    samples = {}
}

-- Enhanced UI Loading with Fallbacks
local Fluent, SaveManager, InterfaceManager

local function loadUI()
    local loadAttempts = 0
    local maxAttempts = 3

    while loadAttempts < maxAttempts do
        local success = pcall(function()
            Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
            SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
            InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
        end)

        if success and Fluent then
            break
        else
            loadAttempts = loadAttempts + 1
            task.wait(1)
        end
    end

    if not Fluent then
        error("Failed to load UI library after " .. maxAttempts .. " attempts")
    end
end

loadUI()

-- Enhanced Safe Index Function with Better Error Handling
local function safeIndex(t, index, fallback)
    if type(t) ~= "table" and type(t) ~= "userdata" then
        return fallback
    end

    local success, result = pcall(function()
        return t[index]
    end)

    if success then
        return result ~= nil and result or fallback
    else
        return fallback
    end
end

-- Enhanced Window Creation with Error Handling
local Window
local function createWindow()
    local success = pcall(function()
        Window = Fluent:CreateWindow({
            Title = "Sense Hub - Enhanced Free",
            SubTitle = "by Veylo (Enhanced)",
            TabWidth = 160,
            Size = UDim2.fromOffset(595, 355),
            Acrylic = true,
            Theme = "Dark",
            MinimizeKey = Enum.KeyCode.LeftControl,
            CanResize = true,
            ScrollSpeed = 30,
            ScrollingEnabled = true
        })
    end)

    if not success or not Window then
        error("Failed to create UI window")
    end
end

createWindow()

-- Enhanced Tab Creation
local Tabs = {}
local function createTabs()
    local success = pcall(function()
        Tabs = {
            Catching = Window:AddTab({ Title = "Catching", Icon = "radio", ScrollingEnabled = true }),
            Physics = Window:AddTab({ Title = "Physics", Icon = "rocket", ScrollingEnabled = true }),
            Player = Window:AddTab({ Title = "Player", Icon = "user", ScrollingEnabled = true }),
            Settings = Window:AddTab({ Title = "Settings", Icon = "settings", ScrollingEnabled = true })
        }
    end)

    if not success then
        error("Failed to create UI tabs")
    end
end

createTabs()

local Options = Fluent.Options

-- Enhanced Mobile UI with Better Detection Evasion
local toggleButton = nil

task.spawn(function()
    if not getgenv().LoadedMobileUI then
        getgenv().LoadedMobileUI = true

        local success = pcall(function()
            local OpenUI = Instance.new("ScreenGui")
            local ImageButton = Instance.new("ImageButton")
            local UICorner = Instance.new("UICorner")

            OpenUI.Name = "OpenUI_" .. tostring(math.random(10000, 99999))
            OpenUI.Parent = (gethui and gethui()) or game:GetService("CoreGui")
            OpenUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

            ImageButton.Parent = OpenUI
            ImageButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
            ImageButton.BackgroundTransparency = 0.2
            ImageButton.Position = UDim2.new(0, 10, 0, 10)
            ImageButton.Size = UDim2.new(0, 50, 0, 50)
            ImageButton.Image = "rbxassetid://129937299302497"
            ImageButton.ImageTransparency = 0.1
            ImageButton.Draggable = true
            ImageButton.BorderSizePixel = 2
            ImageButton.BorderColor3 = Color3.fromRGB(0, 255, 255)

            UICorner.CornerRadius = UDim.new(0, 8)
            UICorner.Parent = ImageButton

            ImageButton.MouseButton1Click:Connect(function()
                local vim = game:GetService("VirtualInputManager")
                if vim then
                    vim:SendKeyEvent(true, Enum.KeyCode.LeftControl, false, game)
                end
            end)

            toggleButton = OpenUI
        end)

        if not success then
            warn("Failed to create mobile UI")
        end
    end
end)

-- Enhanced Rainbow Color Function with Natural Variation
local function getRainbowColor(speed)
    local time = (os.clock() + executionStartTime) * (speed or 1)
    local offset = math.random() * 0.1 -- Add slight randomization
    local r = math.sin(time + offset) * 127 + 128
    local g = math.sin(time + 2 + offset) * 127 + 128
    local b = math.sin(time + 4 + offset) * 127 + 128
    return Color3.fromRGB(
        math.clamp(r, 0, 255),
        math.clamp(g, 0, 255),
        math.clamp(b, 0, 255)
    )
end

-- Enhanced Beam Projectile Function with Better Accuracy
function beamProjectile(g, v0, x0, t1)
    local c = 0.5 * 0.5 * 0.5
    local p3 = 0.5 * g * t1 * t1 + v0 * t1 + x0
    local p2 = p3 - (g * t1 * t1 + v0 * t1) / 3
    local p1 = (c * g * t1 * t1 + 0.5 * v0 * t1 + x0 - c * (x0 + p3)) / (3 * c) - p2

    local curve0 = (p1 - x0).magnitude
    local curve1 = (p2 - p3).magnitude

    local b = (x0 - p3).unit
    local r1 = (p1 - x0).unit
    local u1 = r1:Cross(b).unit
    local r2 = (p2 - p3).unit
    local u2 = r2:Cross(b).unit
    b = u1:Cross(r1).unit

    local cf1 = CFrame.new(
        x0.x, x0.y, x0.z,
        r1.x, u1.x, b.x,
        r1.y, u1.y, b.y,
        r1.z, u1.z, b.z
    )

    local cf2 = CFrame.new(
        p3.x, p3.y, p3.z,
        r2.x, u2.x, b.x,
        r2.y, u2.y, b.y,
        r2.z, u2.z, b.z
    )

    return curve0, -curve1, cf1, cf2
end

-- Enhanced Network Performance Monitoring
local function getPing()
    local success, result = pcall(function()
        return statsService.PerformanceStats.Ping:GetValue()
    end)
    return success and result or 0
end

local function getServerPing()
    local success, result = pcall(function()
        return statsService.Network.ServerStatsItem['Data Ping']:GetValue()
    end)
    return success and result or 0
end

-- Enhanced Ball Finding with Better Performance
local function findClosestBall()
    local lowestDistance = math.huge
    local nearestBall = nil
    local character = player and player.Character

    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return nil
    end

    local hrpPosition = character.HumanoidRootPart.Position

    -- More efficient ball detection
    local balls = {}
    for _, obj in pairs(workspace:GetChildren()) do
        if obj.Name == "Football" and obj:IsA("BasePart") then
            table.insert(balls, obj)
        end
    end

    for _, ball in pairs(balls) do
        local success, distance = pcall(function()
            return (ball.Position - hrpPosition).Magnitude
        end)

        if success and distance < lowestDistance then
            nearestBall = ball
            lowestDistance = distance
        end
    end

    return nearestBall
end

-- Enhanced Part Proximity Function
local function getNearestPartToPartFromParts(part, parts)
    if not part or not parts then return nil end

    local lowestDistance = math.huge
    local nearestPart = nil

    for _, p in pairs(parts) do
        if p and p.Parent then
            local success, distance = pcall(function()
                return (part.Position - p.Position).Magnitude
            end)

            if success and distance < lowestDistance then
                nearestPart = p
                lowestDistance = distance
            end
        end
    end

    return nearestPart
end

-- Enhanced Possessor Detection
local function findPossessor()
    if not players then return nil end

    for _, plr in pairs(players:GetPlayers()) do
        if plr and plr.Character then
            local character = plr.Character
            if character:FindFirstChildWhichIsA("Tool") then
                return character
            end
        end
    end
    return nil
end

-- Enhanced Performance Monitoring
task.spawn(function()
    while task.wait(0.1 + math.random() * 0.05) do -- Randomized intervals
        local currentPing = (getPing() + getServerPing()) / 1000
        ping = currentPing

        -- Update performance data for natural behavior
        table.insert(performanceData.samples, currentPing)
        if #performanceData.samples > 50 then
            table.remove(performanceData.samples, 1)
        end

        local sum = 0
        for _, sample in pairs(performanceData.samples) do
            sum = sum + sample
        end
        performanceData.avgPing = sum / #performanceData.samples
    end
end)

-- Enhanced FPS Monitoring
task.spawn(function()
    local fpsCounter = 0
    local lastFpsUpdate = tick()

    runService.RenderStepped:Connect(function()
        fpsCounter = fpsCounter + 1

        local currentTime = tick()
        if currentTime - lastFpsUpdate >= 1 then
            fps = fpsCounter
            fpsCounter = 0
            lastFpsUpdate = currentTime

            -- Update average FPS
            table.insert(performanceData.samples, fps)
            if #performanceData.samples > 30 then
                table.remove(performanceData.samples, 1)
            end
        end
    end)
end)

-- UI ELEMENTS WITH ENHANCED FEATURES

-- PHYSICS TAB
local VisualizeBallPathToggle = Tabs.Physics:AddToggle("VisualizeBallPath", {
    Title = "Visualize Ball Path",
    Default = false,
    Description = "Shows the predicted path of the ball"
})

-- CATCHING TAB - Enhanced Magnets
local MagnetsToggle = Tabs.Catching:AddToggle("Magnets", {
    Title = "Magnets",
    Default = false,
    Description = "Intelligent ball catching assistance"
})

local MagnetsType = Tabs.Catching:AddDropdown("MagnetsType", {
    Title = "Mode",
    Values = {"Blatant", "Legit", "Stealth"},
    Default = "Stealth",
    Description = "Detection evasion level"
})

local MagnetsCustomRadius = Tabs.Catching:AddSlider("MagnetsCustomRadius", {
    Title = "Radius",
    Description = "Effective range for ball magnetism",
    Default = 12,
    Min = 5,
    Max = 20,
    Rounding = 1
})

local ShowMagHitbox = Tabs.Catching:AddToggle("ShowMagHitbox", {
    Title = "Visualise Hitbox",
    Default = false,
    Description = "Shows the active magnetism area"
})

local RainbowMagnetsToggle = Tabs.Catching:AddToggle("RainbowMagnets", {
    Title = "Rainbow Magnets",
    Default = false,
    Description = "Aesthetic rainbow effect for hitbox"
})

local RainbowMagnetsSpeed = Tabs.Catching:AddSlider("RainbowMagnetsSpeed", {
    Title = "Rainbow Speed",
    Description = "Color transition speed",
    Default = 2,
    Min = 1,
    Max = 5,
    Rounding = 1
})

-- Enhanced Pull Vector System
local PullVectorToggle = Tabs.Catching:AddToggle("PullVector", {
    Title = "Smart Positioning",
    Default = false,
    Description = "Intelligently positions you for catches"
})

local PullVectorDistance = Tabs.Catching:AddSlider("PullVectorDistance", {
    Title = "Activation Range",
    Description = "Distance to begin positioning",
    Default = 35,
    Min = 15,
    Max = 60,
    Rounding = 1
})

local PullVectorType = Tabs.Catching:AddDropdown("PullVectorType", {
    Title = "Movement Type",
    Values = {"Smooth", "Instant", "Natural"},
    Default = "Natural"
})

local PullVectorPower = Tabs.Catching:AddSlider("PullVectorPower", {
    Title = "Intensity",
    Description = "Movement force multiplier",
    Default = 2,
    Min = 1,
    Max = 4,
    Rounding = 1
})

-- PLAYER TAB - Enhanced Features
local ArmResizements = Tabs.Player:AddToggle("ArmResizements", {
    Title = "Reach Enhancement",
    Default = false,
    Description = "Extends effective catching range"
})

local ArmResizementValue = Tabs.Player:AddSlider("ArmResizementValue", {
    Title = "Extension Level",
    Description = "Reach multiplier (0=normal, 3=extended)",
    Default = 1.5,
    Min = 0,
    Max = 3,
    Rounding = 0.1
})

local SpeedToggle = Tabs.Player:AddToggle("Speed", {
    Title = "Movement Enhancement",
    Default = false,
    Description = "Improves movement speed naturally"
})

local SpeedValue = Tabs.Player:AddSlider("SpeedValue", {
    Title = "Speed Level",
    Description = "Movement speed multiplier",
    Default = 21,
    Min = 16,
    Max = 25,
    Rounding = 0.5
})

local JumpPowerToggle = Tabs.Player:AddToggle("JumpPower", {
    Title = "Jump Enhancement",
    Default = false,
    Description = "Increases vertical mobility"
})

local JumpPowerValue = Tabs.Player:AddSlider("JumpPowerValue", {
    Title = "Jump Force",
    Description = "Vertical power multiplier",
    Default = 52,
    Min = 50,
    Max = 65,
    Rounding = 1
})

local AngleAssistToggle = Tabs.Player:AddToggle("AngleAssist", {
    Title = "Angle Optimizer",
    Default = false,
    Description = "Optimizes movement angles"
})

local AngleAssistJP = Tabs.Player:AddSlider("AngleAssistJP", {
    Title = "Angle Power",
    Description = "Angular adjustment force",
    Default = 55,
    Min = 50,
    Max = 70,
    Rounding = 1
})

-- Enhanced Touch Interest Implementation
local originalFireTouchInterest = firetouchinterest or function() end

-- Enhanced Solara-specific Implementation
if IS_SOLARA then
    firetouchinterest = function(part2, part1, state)
        if AC_BYPASS then
            return originalFireTouchInterest(part2, part1, state)
        else
            -- Enhanced natural movement simulation
            local success = pcall(function()
                if not part1 or not part2 then return end

                local fakeBall = fakeBalls[part1]
                if not fakeBall then return end

                local direction = (part2.Position - fakeBall.Position).Unit
                local distance = (part2.Position - fakeBall.Position).Magnitude

                -- More natural movement simulation
                local steps = math.random(3, 7)
                for i = 1, steps do
                    local percentage = i / steps + math.random(-0.02, 0.02)
                    local newPos = fakeBall.CFrame + (direction * distance * percentage)

                    -- Add slight randomization for naturalness
                    local offset = Vector3.new(
                        math.random(-10, 10) / 100,
                        math.random(-5, 5) / 100,
                        math.random(-10, 10) / 100
                    )

                    part1.CFrame = newPos + offset

                    if i < steps then
                        task.wait(math.random(1, 3) / 1000) -- Natural timing
                    end
                end
            end)

            if not success then
                -- Fallback to original if simulation fails
                return originalFireTouchInterest(part2, part1, state)
            end
        end
    end
else
    firetouchinterest = originalFireTouchInterest
end

-- Enhanced Data Structures with Memory Management
local fakeBalls = {}
local pullVectoredBalls = {}
local velocity = {}
local isCatching = false
local ballTrails = {}
local performanceOptimization = {
    lastCleanup = 0,
    cleanupInterval = 25, -- Cleanup every 25 seconds
    maxEntries = 100
}

-- Enhanced Visualization Part with Better Performance
local part = Instance.new("Part")
part.Name = "MagnetVisualization_" .. tostring(math.random(10000, 99999))
part.Transparency = 0.6
part.Anchored = true
part.CanCollide = false
part.CastShadow = false
part.Color = Color3.fromRGB(0, 255, 255)
part.Shape = Enum.PartType.Ball
part.Material = Enum.Material.ForceField
part.TopSurface = Enum.SurfaceType.Smooth
part.BottomSurface = Enum.SurfaceType.Smooth

-- Enhanced Memory Management
task.spawn(function()
    while task.wait(performanceOptimization.cleanupInterval + math.random(-2, 2)) do
        local currentTime = tick()
        local cleaned = 0

        -- Clean up fake balls
        for ball, fakeBall in pairs(fakeBalls) do
            if not ball or not ball.Parent or not fakeBall or not fakeBall.Parent then
                if fakeBall and fakeBall.Parent then
                    fakeBall:Destroy()
                end
                fakeBalls[ball] = nil
                cleaned = cleaned + 1
            end
        end

        -- Clean up pull vectored balls
        for ball, data in pairs(pullVectoredBalls) do
            if not ball or not ball.Parent or
               (data.lastUsed and currentTime - data.lastUsed > 30) then
                pullVectoredBalls[ball] = nil
                cleaned = cleaned + 1
            end
        end

        -- Clean up velocity data
        for ball, _ in pairs(velocity) do
            if not ball or not ball.Parent then
                velocity[ball] = nil
                cleaned = cleaned + 1
            end
        end

        -- Clean up ball trails
        for ball, _ in pairs(ballTrails) do
            if not ball or not ball.Parent then
                ballTrails[ball] = nil
                cleaned = cleaned + 1
            end
        end

        -- Force garbage collection if too many objects cleaned
        if cleaned > 20 then
            collectgarbage("collect")
        end

        performanceOptimization.lastCleanup = currentTime
    end
end)

-- Enhanced Character Catching Detection
local function onCharacterCatching(character)
    if not character then return end

    local success = pcall(function()
        local arm = character:WaitForChild('Left Arm', 10)
        if not arm then return end

        local connection
        connection = arm.ChildAdded:Connect(function(child)
            if not child:IsA("Weld") then return end

            isCatching = true

            -- Enhanced catch effect
            if Options.Magnets and Options.Magnets.Value then
                local ball = findClosestBall()
                if ball then
                    -- Create subtle catch effect
                    task.spawn(function()
                        local effect = Instance.new("Explosion")
                        effect.Position = ball.Position
                        effect.BlastRadius = 0
                        effect.BlastPressure = 0
                        effect.Visible = false
                        effect.Parent = workspace

                        debris:AddItem(effect, 2)
                    end)
                end
            end

            -- Natural catch timing
            task.wait(1.5 + math.random() * 0.4)
            isCatching = false
        end)

        -- Clean up connection when character is removed
        character.AncestryChanged:Connect(function()
            if not character.Parent and connection then
                connection:Disconnect()
            end
        end)
    end)

    if not success then
        warn("Failed to set up catching detection for character")
    end
end

-- Enhanced Ball Detection and Tracking
workspace.ChildAdded:Connect(function(ball)
    if ball.Name ~= "Football" then return end
    if not ball:IsA("BasePart") then return end

    -- Small delay to ensure ball is fully loaded
    task.wait(0.05)

    -- Enhanced ball tracking
    task.spawn(function()
        local ballId = tostring(ball) .. "_" .. tick()
        ballTrails[ball] = {
            id = ballId,
            created = tick(),
            positions = {},
            velocities = {}
        }

        -- Velocity tracking with improved accuracy
        local lastPosition = ball.Position
        local lastCheck = os.clock()
        local initialVelocity = Vector3.new(0, 0, 0)

        pcall(function()
            if ball and ball:IsA("BasePart") then
                initialVelocity = ball.Velocity
            end
        end)

        -- Enhanced Solara fake ball system
        if IS_SOLARA and ball:FindFirstChildWhichIsA("Trail") and not ball.Anchored and camera.CameraSubject ~= ball then
            local success = pcall(function()
                local fakeBall = ball:Clone()
                fakeBall.Name = "FFootball_" .. tostring(math.random(1000, 9999))
                fakeBall.Parent = workspace
                fakeBall.Anchored = true
                fakeBall.CanCollide = false

                -- Clean up fake ball effects
                for _, child in pairs(fakeBall:GetChildren()) do
                    if child:IsA("PointLight") or child:IsA("Sound") then
                        child:Destroy()
                    end
                end

                ball.Transparency = 1
                local spiralDegrees = 0
                fakeBalls[ball] = fakeBall

                -- Enhanced physics simulation
                task.spawn(function()
                    local lastUpdate = tick()

                    while ball.Parent == workspace and fakeBall.Parent do
                        local currentTime = tick()
                        local dt = currentTime - lastUpdate
                        lastUpdate = currentTime

                        if dt > 0 and dt < 0.1 then -- Prevent large time jumps
                            spiralDegrees = spiralDegrees + (1200 + math.random(-100, 100)) * dt
                            initialVelocity = initialVelocity + Vector3.new(0, -28 * dt, 0)

                            -- Add slight air resistance for realism
                            initialVelocity = initialVelocity * (1 - 0.01 * dt)

                            fakeBall.Position = fakeBall.Position + initialVelocity * dt

                            local lookDirection = initialVelocity.Magnitude > 0.1 and initialVelocity.Unit or Vector3.new(0, 0, 1)
                            fakeBall.CFrame = CFrame.lookAt(fakeBall.Position, fakeBall.Position + lookDirection) *
                                            CFrame.Angles(math.rad(90), math.rad(spiralDegrees), 0)
                        end

                        -- Hide original ball trail
                        pcall(function()
                            local trail = ball:FindFirstChildWhichIsA("Trail")
                            if trail then
                                trail.Enabled = false
                            end
                        end)

                        task.wait(0.016) -- ~60 FPS
                    end

                    -- Cleanup
                    if fakeBall and fakeBall.Parent then
                        fakeBall:Destroy()
                    end
                    fakeBalls[ball] = nil
                end)
            end)

            if not success then
                warn("Failed to create fake ball for Solara")
            end
        end

        -- Enhanced velocity tracking
        task.spawn(function()
            while ball.Parent do
                task.wait(0.08 + math.random() * 0.02) -- Slightly randomized intervals

                local currentTime = os.clock()
                local timeDelta = currentTime - lastCheck

                if timeDelta > 0 then
                    pcall(function()
                        if ball and ball:IsA("BasePart") then
                            local currentPosition = ball.Position
                            local calculatedVelocity = (currentPosition - lastPosition) / timeDelta

                            velocity[ball] = calculatedVelocity

                            -- Store position history for better prediction
                            local trail = ballTrails[ball]
                            if trail then
                                table.insert(trail.positions, currentPosition)
                                table.insert(trail.velocities, calculatedVelocity)

                                -- Limit history size for performance
                                if #trail.positions > 20 then
                                    table.remove(trail.positions, 1)
                                    table.remove(trail.velocities, 1)
                                end
                            end

                            lastPosition = currentPosition
                        end
                    end)
                end

                lastCheck = currentTime
            end

            -- Cleanup when ball is removed
            velocity[ball] = nil
            ballTrails[ball] = nil

            local fakeBall = fakeBalls[ball]
            if fakeBall and fakeBall.Parent then
                fakeBall:Destroy()
            end
            fakeBalls[ball] = nil
        end)

        -- Enhanced Ball Path Visualization
        task.spawn(function()
            if not (Options.VisualizeBallPath and Options.VisualizeBallPath.Value) then
                return
            end

            local success = pcall(function()
                local currentInitialVelocity = Vector3.new(0, 0, 0)

                pcall(function()
                    if ball and ball:IsA("BasePart") then
                        currentInitialVelocity = ball.Velocity
                    end
                end)

                local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment")
                a0.Parent = workspace.Terrain
                a1.Parent = workspace.Terrain

                local beam = Instance.new("Beam")
                beam.Name = "BallPath_" .. ballId
                beam.Parent = workspace.Terrain
                beam.Attachment0 = a0
                beam.Attachment1 = a1
                beam.Segments = 200
                beam.Width0 = 0.3
                beam.Width1 = 0.1
                beam.Transparency = NumberSequence.new{
                    NumberSequenceKeypoint.new(0, 0.3),
                    NumberSequenceKeypoint.new(1, 0.8)
                }
                beam.Color = ColorSequence.new(Color3.fromRGB(0, 200, 255))
                beam.FaceCamera = true

                local g = Vector3.new(0, -28, 0)
                local x0 = ball.Position
                local v0 = currentInitialVelocity
                local flightTime = math.min(5, math.max(1, currentInitialVelocity.Magnitude / 10))

                local curve0, curve1, cf1, cf2 = beamProjectile(g, v0, x0, flightTime)

                beam.CurveSize0 = curve0
                beam.CurveSize1 = curve1
                a0.CFrame = a0.Parent.CFrame:inverse() * cf1
                a1.CFrame = a1.Parent.CFrame:inverse() * cf2

                -- Update beam periodically for moving balls
                local beamUpdateConnection
                beamUpdateConnection = runService.Heartbeat:Connect(function()
                    if not ball or ball.Parent ~= workspace then
                        beamUpdateConnection:Disconnect()
                        return
                    end

                    pcall(function()
                        local newVelocity = velocity[ball] or ball.Velocity or v0
                        local newPosition = ball.Position

                        if (newPosition - x0).Magnitude > 2 or (newVelocity - v0).Magnitude > 5 then
                            x0 = newPosition
                            v0 = newVelocity

                            local newCurve0, newCurve1, newCf1, newCf2 = beamProjectile(g, v0, x0, flightTime)
                            beam.CurveSize0 = newCurve0
                            beam.CurveSize1 = newCurve1
                            a0.CFrame = a0.Parent.CFrame:inverse() * newCf1
                            a1.CFrame = a1.Parent.CFrame:inverse() * newCf2
                        end
                    end)
                end)

                -- Cleanup when ball disappears
                repeat
                    task.wait(0.1)
                until not ball or ball.Parent ~= workspace

                beamUpdateConnection:Disconnect()
                if beam then beam:Destroy() end
                if a0 then a0:Destroy() end
                if a1 then a1:Destroy() end
            end)

            if not success then
                warn("Failed to create ball path visualization")
            end
        end)
    end)
end)

-- Enhanced Magnet System with Advanced Detection Evasion
task.spawn(function()
    local lastMagnetTime = 0
    local magnetCooldown = 0.1

    while task.wait(1/75) do -- Slightly slower than 60fps for naturalness
        local currentTime = tick()

        -- Enforce cooldown to prevent spam detection
        if currentTime - lastMagnetTime < magnetCooldown then
            continue
        end

        local ball = findClosestBall()
        local character = player.Character
        local showHitboxOption = safeIndex(Options.ShowMagHitbox, "Value", false)
        local magnetsEnabled = safeIndex(Options.Magnets, "Value", false)

        -- Always manage part visibility properly
        if not ball or not character or not magnetsEnabled then
            if part and part.Parent then
                part.Parent = nil
            end
            continue
        end

        local catchLeft = character:FindFirstChild("CatchLeft")
        local catchRight = character:FindFirstChild("CatchRight")

        if not catchLeft or not catchRight then
            if part and part.Parent then
                part.Parent = nil
            end
            continue
        end

        local catchPart = getNearestPartToPartFromParts(ball, {catchLeft, catchRight})
        if not catchPart then
            if part and part.Parent then
                part.Parent = nil
            end
            continue
        end

        local distance = (catchPart.Position - ball.Position).Magnitude
        local magnetType = safeIndex(Options.MagnetsType, "Value", "Stealth")

        -- Enhanced radius calculation based on type
        local radius
        if magnetType == "Blatant" then
            radius = 25
        elseif magnetType == "Legit" then
            radius = 15
        else -- Stealth
            radius = 10
        end

        -- Apply custom radius with limits
        if Options.MagnetsCustomRadius and Options.MagnetsCustomRadius.Value then
            local customRadius = math.clamp(Options.MagnetsCustomRadius.Value, 5, 20)
            radius = math.min(radius, customRadius)
        end

        -- Enhanced part management
        if part then
            local ballPosition = (fakeBalls[ball] and fakeBalls[ball].Position) or ball.Position
            part.Position = ballPosition
            part.Size = Vector3.new(radius, radius, radius)
            part.Material = Enum.Material.ForceField

            -- Enhanced transparency for stealth
            if magnetType == "Stealth" then
                part.Transparency = 0.8
            else
                part.Transparency = 0.6
            end

            -- Enhanced color system
            if safeIndex(Options.RainbowMagnets, "Value", false) then
                local speed = safeIndex(Options.RainbowMagnetsSpeed, "Value", 2)
                part.Color = getRainbowColor(speed)
            else
                -- Subtle color variation for naturalness
                local baseColor = Color3.fromRGB(0, 255, 255)
                local variation = math.sin(currentTime * 2) * 0.1
                part.Color = Color3.fromRGB(
                    math.clamp(baseColor.R * 255 + variation * 50, 0, 255),
                    255,
                    255
                )
            end

            -- Show/hide based on setting
            if showHitboxOption then
                part.Parent = workspace
            else
                part.Parent = nil
            end
        end

        -- Enhanced magnet functionality with detection evasion
        if distance < radius and not isCatching then
            -- Add randomization to prevent detection patterns
            local activationChance = 1.0

            if magnetType == "Stealth" then
                activationChance = 0.85 -- 85% activation rate for naturalness
            elseif magnetType == "Legit" then
                activationChance = 0.95 -- 95% activation rate
            end

            if math.random() <= activationChance then
                -- Enhanced timing for Solara
                if IS_SOLARA then
                    -- More natural approach for Solara detection
                    task.spawn(function()
                        local delay = math.random(5, 25) / 1000 -- 5-25ms delay
                        task.wait(delay)

                        pcall(function()
                            firetouchinterest(catchPart, ball, 0)
                            task.wait(0.001)
                            firetouchinterest(catchPart, ball, 1)
                        end)
                    end)
                else
                    -- Standard implementation for other executors
                    pcall(function()
                        firetouchinterest(catchPart, ball, 0)
                        firetouchinterest(catchPart, ball, 1)
                    end)
                end

                lastMagnetTime = currentTime
            end
        end
    end
end)

-- Enhanced Pull Vector System with Natural Movement
task.spawn(function()
    local lastPullTime = 0
    local pullCooldown = 0.05

    while task.wait(0.02) do
        local currentTime = tick()

        if currentTime - lastPullTime < pullCooldown then
            continue
        end

        local ball = findClosestBall()
        if not ball then continue end

        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

        if not ball:FindFirstChildWhichIsA("Trail") then continue end
        if not character or not humanoidRootPart then continue end
        if not safeIndex(Options.PullVector, "Value", false) then continue end
        if ball.Anchored then continue end

        local distance = (humanoidRootPart.Position - ball.Position).Magnitude
        local maxDistance = safeIndex(Options.PullVectorDistance, "Value", 35)

        if distance > maxDistance then continue end

        -- Enhanced direction calculation with prediction
        local ballVelocity = velocity[ball] or Vector3.new(0, 0, 0)
        local predictedPosition = ball.Position + ballVelocity * 0.2 -- Predict 0.2s ahead
        local direction = (predictedPosition - humanoidRootPart.Position).Unit

        local pullType = safeIndex(Options.PullVectorType, "Value", "Natural")
        local power = safeIndex(Options.PullVectorPower, "Value", 2)

        -- Enhanced movement with detection evasion
        if pullType == "Instant" then
            pcall(function()
                local teleportDistance = 8 + (power * 3)
                local newPosition = humanoidRootPart.Position + direction * teleportDistance

                -- Add slight randomization to prevent pattern detection
                local randomOffset = Vector3.new(
                    math.random(-50, 50) / 100,
                    0,
                    math.random(-50, 50) / 100
                )

                humanoidRootPart.CFrame = CFrame.new(newPosition + randomOffset, newPosition + direction)
            end)
        elseif pullType == "Natural" then
            pcall(function()
                -- Natural acceleration that mimics player input
                local baseVelocity = humanoidRootPart.Velocity
                local targetVelocity = direction * (power * 12 + math.random(-2, 2))

                -- Smooth interpolation for natural feel
                local lerpFactor = math.min(0.3, power * 0.1)
                local newVelocity = baseVelocity:lerp(targetVelocity, lerpFactor)

                humanoidRootPart.Velocity = Vector3.new(newVelocity.X, baseVelocity.Y, newVelocity.Z)
            end)
        else -- Smooth
            pcall(function()
                local pullForce = direction * power * 20
                humanoidRootPart.Velocity = Vector3.new(pullForce.X, humanoidRootPart.Velocity.Y, pullForce.Z)
            end)
        end

        lastPullTime = currentTime

        -- Mark ball as being pulled for tracking
        pullVectoredBalls[ball] = {
            lastUsed = currentTime,
            pullCount = (pullVectoredBalls[ball] and pullVectoredBalls[ball].pullCount or 0) + 1
        }
    end
end)

-- Enhanced Character Movement System
local function onCharacterMovement(character)
    if not character then return end

    local success = pcall(function()
        local humanoid = character:WaitForChild("Humanoid", 10)
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 10)

        if not humanoid or not humanoidRootPart then return end

        -- Enhanced jump power management for AC bypass
        if AC_BYPASS then
            task.spawn(function()
                while humanoid.Parent and character.Parent do
                    task.wait(0.1 + math.random() * 0.05)

                    local jumpEnabled = safeIndex(Options.JumpPower, "Value", false)
                    local jumpValue = safeIndex(Options.JumpPowerValue, "Value", 50)

                    if jumpEnabled then
                        humanoid.JumpPower = jumpValue
                    else
                        humanoid.JumpPower = 50
                    end
                end
            end)
        end

        -- Enhanced jump event handling for non-bypass mode
        local jumpConnection = humanoid.Jumping:Connect(function()
            if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
            if AC_BYPASS then return end

            task.spawn(function()
                task.wait(0.03 + math.random() * 0.02) -- Natural delay

                if safeIndex(Options.JumpPower, "Value", false) then
                    pcall(function()
                        local jumpValue = safeIndex(Options.JumpPowerValue, "Value", 50)
                        local jumpBoost = math.max(0, jumpValue - 50)

                        if jumpBoost > 0 then
                            humanoidRootPart.Velocity = humanoidRootPart.Velocity + Vector3.new(0, jumpBoost, 0)
                        end
                    end)
                end
            end)
        end)

        -- Cleanup connection when character is removed
        character.AncestryChanged:Connect(function()
            if not character.Parent and jumpConnection then
                jumpConnection:Disconnect()
            end
        end)
    end)

    if not success then
        warn("Failed to set up character movement for: " .. tostring(character))
    end
end

-- Initialize movement system for existing character
if player.Character then
    onCharacterMovement(player.Character)
end

-- Setup for future characters
player.CharacterAdded:Connect(onCharacterMovement)

-- Enhanced Walk Speed System with Better Detection Evasion
runService:BindToRenderStep("enhancedWalkSpeed", Enum.RenderPriority.Character.Value, function()
    local character = player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")

    if not character or not humanoid then return end
    if humanoid:GetState() ~= Enum.HumanoidStateType.Running then return end
    if humanoid.WalkSpeed == 0 then return end
    if not character:FindFirstChild("HumanoidRootPart") then return end

    local moveDirection
    local humanoidRootPart = character.HumanoidRootPart

    -- Enhanced MoveTo detection with better timing
    if moveToUsing and #moveToUsing > 0 then
        local lastMoveTime = moveToUsing[#moveToUsing] or 0
        if (os.clock() - lastMoveTime) < 0.6 then -- Extended window for better detection
            pcall(function()
                if humanoid.WalkToPoint and humanoidRootPart then
                    local direction = (humanoid.WalkToPoint - humanoidRootPart.Position)
                    if direction.Magnitude > 0.1 then
                        moveDirection = direction.Unit
                    end
                end
            end)
        end
    end

    if not moveDirection then
        moveDirection = humanoid.MoveDirection
    end

    local currentVel = Vector3.new(0, 0, 0)
    pcall(function()
        currentVel = humanoidRootPart.Velocity
    end)

    -- Enhanced speed system
    if safeIndex(Options.Speed, "Value", false) then
        local speedValue = safeIndex(Options.SpeedValue, "Value", 21)

        -- Clamp speed to reasonable limits
        speedValue = math.clamp(speedValue, 16, 25)

        pcall(function()
            -- Natural speed application with slight variation
            local naturalVariation = 1 + (math.sin(os.clock() * 2) * 0.05) -- 5% variation
            local finalSpeed = speedValue * naturalVariation

            local newVelocity = Vector3.new(
                moveDirection.X * finalSpeed,
                currentVel.Y,
                moveDirection.Z * finalSpeed
            )

            humanoidRootPart.Velocity = newVelocity
        end)
    end
end)

-- Enhanced Periodic Status Updates with Randomization
task.spawn(function()
    while task.wait(0.4 + math.random() * 0.2) do
        -- Speed management for AC bypass mode
        if safeIndex(Options.Speed, "Value", false) and AC_BYPASS then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                local speedValue = safeIndex(Options.SpeedValue, "Value", 21)
                humanoid.WalkSpeed = speedValue
            end
        end

        -- Jump power management for AC bypass mode
        if safeIndex(Options.JumpPower, "Value", false) and AC_BYPASS then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                local jumpValue = safeIndex(Options.JumpPowerValue, "Value", 50)
                humanoid.JumpPower = jumpValue
            end
        end

        -- Enhanced angle assist management
        if safeIndex(Options.AngleAssist, "Value", false) and AC_BYPASS then
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")
            if humanoid then
                local timeSinceAngle = os.clock() - (angleTick or 0)
                if timeSinceAngle < 0.25 then
                    local angleJump = safeIndex(Options.AngleAssistJP, "Value", 55)
                    humanoid.JumpPower = angleJump
                end
            end
        end
    end
end)

-- Enhanced Angle Assist System
task.spawn(function()
    local function hookCharacterForAngles(character)
        if not character then return end

        local success = pcall(function()
            local humanoid = character:WaitForChild("Humanoid", 10)
            local hrp = character:WaitForChild("HumanoidRootPart", 10)

            if not humanoid or not hrp then return end

            local jumpConnection = humanoid.Jumping:Connect(function()
                if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
                if not safeIndex(Options.AngleAssist, "Value", false) then return end
                if AC_BYPASS then return end

                local timeSinceAngle = os.clock() - (angleTick or 0)
                if timeSinceAngle < 0.3 then -- Extended window for better detection
                    task.spawn(function()
                        task.wait(0.01 + math.random() * 0.02) -- Natural delay

                        pcall(function()
                            local angleJump = safeIndex(Options.AngleAssistJP, "Value", 55)
                            local baseJump = safeIndex(Options.JumpPowerValue, "Value", 50)
                            local boost = angleJump - baseJump

                            if boost > 0 then
                                hrp.Velocity = hrp.Velocity + Vector3.new(0, boost, 0)
                            end
                        end)
                    end)
                end
            end)

            -- Cleanup connection
            character.AncestryChanged:Connect(function()
                if not character.Parent and jumpConnection then
                    jumpConnection:Disconnect()
                end
            end)
        end)

        if not success then
            warn("Failed to hook character for angle assist")
        end
    end

    -- Hook existing character
    if player.Character then
        hookCharacterForAngles(player.Character)
    end

    -- Hook future characters
    player.CharacterAdded:Connect(hookCharacterForAngles)

    -- Enhanced mouse behavior detection
    local lastMouseBehavior = userInputService.MouseBehavior

    userInputService:GetPropertyChangedSignal("MouseBehavior"):Connect(function()
        local currentBehavior = userInputService.MouseBehavior

        if lastMouseBehavior == Enum.MouseBehavior.LockCenter and
           currentBehavior ~= Enum.MouseBehavior.LockCenter then
            -- Shift lock was disabled
            angleTick = os.clock()
        end

        lastMouseBehavior = currentBehavior
    end)

    -- Enhanced angle assist main loop
    while task.wait(0.02) do
        local character = player.Character
        if not character then continue end

        local hrp = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")

        if not hrp or not humanoid then continue end
        if not AC_BYPASS then continue end

        local angleEnabled = safeIndex(Options.AngleAssist, "Value", false)
        local jumpEnabled = safeIndex(Options.JumpPower, "Value", false)
        local timeSinceAngle = os.clock() - (angleTick or 0)

        if timeSinceAngle < 0.2 and angleEnabled then
            local angleJump = safeIndex(Options.AngleAssistJP, "Value", 55)
            local baseJump = jumpEnabled and safeIndex(Options.JumpPowerValue, "Value", 50) or 50
            humanoid.JumpPower = math.max(angleJump, baseJump)
        elseif jumpEnabled then
            humanoid.JumpPower = safeIndex(Options.JumpPowerValue, "Value", 50)
        else
            humanoid.JumpPower = 50
        end
    end
end)

-- Enhanced UI Management
if SaveManager and InterfaceManager then
    SaveManager:SetLibrary(Fluent)
    InterfaceManager:SetLibrary(Fluent)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetIgnoreIndexes({})

    InterfaceManager:SetFolder("Sense Hub")
    SaveManager:SetFolder("Sense Hub/ff2_enhanced")

    if Tabs.Settings then
        InterfaceManager:BuildInterfaceSection(Tabs.Settings)
        SaveManager:BuildConfigSection(Tabs.Settings)
    end
end

-- Enhanced Arm Resizing System with Better Detection Evasion
local originalArmSizes = {}
local armResizeConnections = {}

local function resizeArms(character, resizeLevel)
    if not character then return end

    local success = pcall(function()
        local leftArm = character:FindFirstChild("Left Arm")
        local rightArm = character:FindFirstChild("Right Arm")

        if not leftArm or not rightArm then return end

        -- Store original sizes per character instance
        local charId = tostring(character)
        if not originalArmSizes[charId] then
            originalArmSizes[charId] = {
                leftArm = leftArm.Size,
                rightArm = rightArm.Size
            }
        end

        local original = originalArmSizes[charId]
        if not original then return end

        -- Enhanced size calculation with natural limits
        resizeLevel = math.clamp(resizeLevel, 0, 3)
        local lengthMultiplier = 1 + (resizeLevel * 0.25) -- Max 1.75x at level 3

        -- Apply size changes gradually for naturalness
        local targetLeftSize = Vector3.new(
            original.leftArm.X,
            original.leftArm.Y * lengthMultiplier,
            original.leftArm.Z
        )

        local targetRightSize = Vector3.new(
            original.rightArm.X,
            original.rightArm.Y * lengthMultiplier,
            original.rightArm.Z
        )

        -- Smooth transition to prevent detection
        local steps = 5
        for i = 1, steps do
            local alpha = i / steps

            leftArm.Size = original.leftArm:lerp(targetLeftSize, alpha)
            rightArm.Size = original.rightArm:lerp(targetRightSize, alpha)

            if i < steps then
                task.wait(0.02) -- Small delay for smooth transition
            end
        end
    end)

    if not success then
        warn("Failed to resize arms for character: " .. tostring(character))
    end
end

-- Enhanced arm resize event handlers
local function onArmResizeChanged()
    local character = player.Character
    if not character then return end

    task.spawn(function()
        if safeIndex(Options.ArmResizements, "Value", false) and
           safeIndex(Options.ArmResizementValue, "Value") then
            resizeArms(character, Options.ArmResizementValue.Value)
        else
            resizeArms(character, 0) -- Reset to normal
        end
    end)
end

-- Connect arm resizing events
if ArmResizements and ArmResizementValue then
    ArmResizements:OnChanged(onArmResizeChanged)
    ArmResizementValue:OnChanged(onArmResizeChanged)
end

-- Enhanced character spawning for arm resizing
local function onCharacterSpawnedForArms(character)
    if not character then return end

    task.spawn(function()
        -- Wait for character to fully load
        task.wait(1.5 + math.random() * 0.5)

        -- Clean up old data
        local charId = tostring(character)
        originalArmSizes[charId] = nil

        -- Clean up old connections
        if armResizeConnections[character] then
            for _, connection in pairs(armResizeConnections[character]) do
                if connection then
                    connection:Disconnect()
                end
            end
            armResizeConnections[character] = nil
        end

        -- Apply current arm resize settings
        if safeIndex(Options.ArmResizements, "Value", false) and
           safeIndex(Options.ArmResizementValue, "Value") then
            resizeArms(character, Options.ArmResizementValue.Value)
        end

        -- Set up cleanup for when character is removed
        armResizeConnections[character] = {}
        armResizeConnections[character].ancestryChanged = character.AncestryChanged:Connect(function()
            if not character.Parent then
                originalArmSizes[charId] = nil
                if armResizeConnections[character] then
                    for _, connection in pairs(armResizeConnections[character]) do
                        if connection then
                            connection:Disconnect()
                        end
                    end
                    armResizeConnections[character] = nil
                end
            end
        end)
    end)
end

-- Setup arm resizing for existing and future characters
player.CharacterAdded:Connect(onCharacterSpawnedForArms)
if player.Character then
    onCharacterSpawnedForArms(player.Character)
end

-- Enhanced Window Tab Selection
if Window and Window.SelectTab then
    Window:SelectTab(1)
end

-- Enhanced Performance Monitoring and Optimization
task.spawn(function()
    local performanceStats = {
        memory = 0,
        fps = 0,
        ping = 0,
        lastUpdate = 0
    }

    while task.wait(5 + math.random() * 2) do
        -- Monitor performance metrics
        performanceStats.memory = collectgarbage("count")
        performanceStats.fps = fps
        performanceStats.ping = ping
        performanceStats.lastUpdate = tick()

        -- Optimize memory usage if needed
        if performanceStats.memory > 50000 then -- 50MB threshold
            collectgarbage("collect")
        end

        -- Clean up disconnected objects
        local cleaned = 0

        for character, connections in pairs(armResizeConnections) do
            if not character or not character.Parent then
                for _, connection in pairs(connections) do
                    if connection then
                        connection:Disconnect()
                    end
                end
                armResizeConnections[character] = nil
                cleaned = cleaned + 1
            end
        end

        for character, _ in pairs(originalArmSizes) do
            if type(character) == "string" then
                -- Clean up string-based entries for removed characters
                local found = false
                for _, p in pairs(players:GetPlayers()) do
                    if p.Character and tostring(p.Character) == character then
                        found = true
                        break
                    end
                end
                if not found then
                    originalArmSizes[character] = nil
                    cleaned = cleaned + 1
                end
            end
        end

        -- Log performance if debug mode is enabled
        if getgenv().SenseHubDebug then
            print(string.format(
                "[Sense Hub] Performance: %.1fMB memory, %d FPS, %.0fms ping, cleaned %d objects",
                performanceStats.memory / 1024,
                performanceStats.fps,
                performanceStats.ping * 1000,
                cleaned
            ))
        end
    end
end)

-- Enhanced Error Handling and Recovery
task.spawn(function()
    local errorCount = 0
    local lastErrorTime = 0

    -- Monitor for critical errors
    local function handleError(err)
        errorCount = errorCount + 1
        lastErrorTime = tick()

        if getgenv().SenseHubDebug then
            warn("[Sense Hub] Error #" .. errorCount .. ": " .. tostring(err))
        end

        -- Auto-recovery for common issues
        if errorCount > 10 and tick() - lastErrorTime < 30 then
            warn("[Sense Hub] Too many errors, attempting recovery...")

            -- Reset critical variables
            isCatching = false
            angleTick = os.clock()

            -- Clear problematic data
            for ball, _ in pairs(fakeBalls) do
                if fakeBalls[ball] and fakeBalls[ball].Parent then
                    fakeBalls[ball]:Destroy()
                end
                fakeBalls[ball] = nil
            end

            -- Force garbage collection
            collectgarbage("collect")

            errorCount = 0
        end
    end

    -- Set up global error handler
    if getgenv and not getgenv().SenseHubErrorHandler then
        getgenv().SenseHubErrorHandler = handleError
    end
end)

-- Final initialization message
task.spawn(function()
    task.wait(2)
    if starterGui then
        pcall(function()
            starterGui:SetCore("SendNotification", {
                Title = "Sense Hub Enhanced";
                Text = "Successfully loaded with advanced anti-detection!";
                Duration = 3;
            })
        end)
    end
end)

-- Update todos with completion
task.spawn(function()
    task.wait(1)
    print("[Sense Hub Enhanced] Fully loaded and operational!")
end)
