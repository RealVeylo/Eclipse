if getgenv().bleach then warn("Eclipse Hub is already executed") return end
getgenv().bleach = true

loadstring([[
    function LPH_NO_VIRTUALIZE(f) return f end;
]])();

local debris = game:GetService("Debris")
local contentProvider = game:GetService("ContentProvider")
local scriptContext = game:GetService("ScriptContext")
local players = game:GetService("Players")
local tweenService = game:GetService("TweenService")
local statsService = game:GetService("Stats")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local httpService = game:GetService("HttpService")
local starterGui = game:GetService("StarterGui")

local player = players.LocalPlayer
local mouse = player:GetMouse()
local camera = workspace.CurrentCamera
local values = replicatedStorage:FindFirstChild("Values")

local IS_PRACTICE = game.PlaceId == 8206123457
local IS_SOLARA = string.match(getexecutorname(), "Solara")
local AC_BYPASS = IS_PRACTICE

local moveToUsing = {}

if not values or IS_PRACTICE then
	if replicatedStorage:FindFirstChild("Values") then
		replicatedStorage:FindFirstChild("Values"):Destroy()
	end
	values = Instance.new("Folder")
	local status = Instance.new("StringValue")
	status.Name = "Status"
	status.Value = "InPlay"
	status.Parent = values
	values.Parent = replicatedStorage
	values.Name = "Values"
end

if not LPH_OBFUSCATED then
    getfenv().LPH_NO_VIRTUALIZE = function(f) return f end
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Handshake = ReplicatedStorage.Remotes.CharacterSoundEvent
local Hooks = {}
local HandshakeInts = {}

LPH_NO_VIRTUALIZE(function()
    for i, v in getgc() do
        if typeof(v) == "function" and islclosure(v) then
            if (#getprotos(v) == 1) and table.find(getconstants(getproto(v, 1)), 4000001) then
                hookfunction(v, function() end)
            end
        end
    end
end)()

Hooks.__namecall = hookmetamethod(game, "__namecall", LPH_NO_VIRTUALIZE(function(self, ...)
    local Method = getnamecallmethod()
    local Args = {...}

    if not checkcaller() and (self == Handshake) and (Method == "fireServer") and (string.find(Args[1], "AC")) then
        if (#HandshakeInts == 0) then
            HandshakeInts = {table.unpack(Args[2], 2, 18)}
        else
            for i, v in HandshakeInts do
                Args[2][i + 1] = v
            end
        end
    end

    return Hooks.__namecall(self, ...)
end))

task.wait(1)

if not isfolder("Eclipse Hub") then
	makefolder("Eclipse Hub")
end

local ping = 0
local fps = 0

-- Initialize Rayfield UI
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Create the Window
local Window = Rayfield:CreateWindow({
    Name = "Eclipse Hub | Football Fusion 2",
    LoadingTitle = "Eclipse Hub",
    LoadingSubtitle = "by Veylo",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "Eclipse Hub",
        FileName = "config"
    },
    KeySystem = false,
    KeySettings = {
        Title = "Eclipse Hub",
        Subtitle = "Key System",
        Note = "No key needed",
        FileName = "Eclipse Hub Key",
        SaveKey = true,
        Key = {""}
    }
})

-- Create Tabs for each category
local CatchingTab = Window:CreateTab("Catching", 9733400917) -- Using generic icon ID
local PhysicsTab = Window:CreateTab("Physics", 9733400917)
local ThrowingTab = Window:CreateTab("Throwing", 9733400917) -- New Throwing Tab
local VisualsTab = Window:CreateTab("Visuals", 9733400917)
local AutomaticsTab = Window:CreateTab("Automatics", 9733400917)
local PlayerTab = Window:CreateTab("Player", 9733400917)
local ConfigsTab = Window:CreateTab("Configs", 9733400917)

-- Utility functions (unchanged)
function getPing()
	return statsService.PerformanceStats.Ping:GetValue()
end

function getServerPing()
	return statsService.Network.ServerStatsItem['Data Ping']:GetValue()
end

function findClosestBall()
	local lowestDistance = math.huge
	local nearestBall = nil

	local character = player.Character

	for index, ball in pairs(workspace:GetChildren()) do
		if ball.Name ~= "Football" then continue end
		if not ball:IsA("BasePart") then continue end
		if not character:FindFirstChild("HumanoidRootPart") then continue end
		local distance = (ball.Position - character.HumanoidRootPart.Position).Magnitude

		if distance < lowestDistance then
			nearestBall = ball
			lowestDistance = distance
		end
	end

	return nearestBall
end

function beamProjectile(g, v0, x0, t1)
	local c = 0.5*0.5*0.5;
	local p3 = 0.5*g*t1*t1 + v0*t1 + x0;
	local p2 = p3 - (g*t1*t1 + v0*t1)/3;
	local p1 = (c*g*t1*t1 + 0.5*v0*t1 + x0 - c*(x0+p3))/(3*c) - p2;

	local curve0 = (p1 - x0).magnitude;
	local curve1 = (p2 - p3).magnitude;

	local b = (x0 - p3).unit;
	local r1 = (p1 - x0).unit;
	local u1 = r1:Cross(b).unit;
	local r2 = (p2 - p3).unit;
	local u2 = r2:Cross(b).unit;
	b = u1:Cross(r1).unit;

	local cf1 = CFrame.new(
		x0.x, x0.y, x0.z,
		r1.x, u1.x, b.x,
		r1.y, u1.y, b.y,
		r1.z, u1.z, b.z
	)

	local cf2 = CFrame.new(
		p3.x, p3.y, p3.z,
		r2.x, u2.x, b.x,
		r2.y, u2.y, b.y,
		r2.z, u2.z, b.z
	)

	return curve0, -curve1, cf1, cf2;
end

function getNearestPartToPartFromParts(part, parts)
	local lowestDistance = math.huge
	local nearestPart = nil

	for index, p in pairs(parts) do
		local distance = (part.Position - p.Position).Magnitude

		if distance < lowestDistance then
			nearestPart = p
			lowestDistance = distance
		end
	end

	return nearestPart
end

task.spawn(function()
	while true do
		task.wait(0.1)
		ping = ( getPing() + getServerPing() ) / 1000
	end
end)

task.spawn(function()
	runService.RenderStepped:Connect(function()
		fps += 1
		task.delay(1, function()
			fps -= 1
		end)
	end)
end)

-- Create a configSavingUI (unchanged)
local configSavingUI = game:GetObjects("rbxassetid://18187656247")[1]:Clone()
configSavingUI.Parent = (gethui and gethui()) or game:GetService("CoreGui")
configSavingUI.Enabled = false

-- CATCHING SECTION
local fakeBalls = {}
local pullVectoredBalls = {}

-- Create Magnets Section in Catching Tab
local MagnetsSection = CatchingTab:CreateSection("Magnets")

-- Create Magnet Type Dropdown
local magnetsType = CatchingTab:CreateDropdown({
    Name = "Type",
    Options = {"Blatant", "Legit", "League", "Custom"},
    CurrentOption = "Blatant",
    Flag = "MagnetsType",
    Callback = function(Option) end
})

-- Create Custom Radius Slider
local magnetsCustomRadius = CatchingTab:CreateSlider({
    Name = "Custom Radius",
    Range = {0, 70},
    Increment = 1,
    Suffix = "",
    CurrentValue = 10,
    Flag = "MagnetsCustomRadius",
    Callback = function(Value) end
})

-- Create Show Hitbox Toggle
local showMagHitbox = CatchingTab:CreateToggle({
    Name = "Show Hitbox",
    CurrentValue = false,
    Flag = "ShowMagHitbox",
    Callback = function(Value) end
})

-- Modify firetouchinterest for Solara
firetouchinterest = (IS_SOLARA) and function(part2, part1, state)
    if AC_BYPASS then
        part1.CFrame = part2.CFrame
    else
        state = state == 1
        local fakeBall = fakeBalls[part1]
        if not fakeBall then return end

        local direction = (part2.Position - fakeBall.Position).Unit
        local distance = (part2.Position - fakeBall.Position).Magnitude

        for i = 1,5,1 do
            local percentage = i/5 + Random.new():NextNumber(0.01, 0.02)
            part1.CFrame = fakeBall.CFrame + (direction * distance * percentage)
        end
    end
end or firetouchinterest

-- Create PullVector Section
local PullVectorSection = CatchingTab:CreateSection("Pull Vector")

-- Create PullVector Distance Slider
local pullVectorDistance = CatchingTab:CreateSlider({
    Name = "Distance",
    Range = {0, 100},
    Increment = 1,
    Suffix = "",
    CurrentValue = 50,
    Flag = "PullVectorDistance",
    Callback = function(Value) end
})

-- Create PullVector Type Dropdown
local pullVectorType = CatchingTab:CreateDropdown({
    Name = "Type",
    Options = {"Glide", "Teleport"},
    CurrentOption = "Glide",
    Flag = "PullVectorType",
    Callback = function(Option) end
})

-- Create PullVector Power Slider
local pullVectorPower = CatchingTab:CreateSlider({
    Name = "Power",
    Range = {1, 5},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 2.5,
    Flag = "PullVectorPower",
    Callback = function(Value) end
})

-- Master Toggle for Magnets
local magnetsMasterToggle = CatchingTab:CreateToggle({
    Name = "Magnets",
    CurrentValue = false,
    Flag = "MagnetsMasterToggle",
    Callback = function(Value) end
})

-- Master Toggle for PullVector
local pullVectorMasterToggle = CatchingTab:CreateToggle({
    Name = "Pull Vector",
    CurrentValue = false,
    Flag = "PullVectorMasterToggle",
    Callback = function(Value) end
})

local velocity = {}
local isCatching = false

local part = Instance.new("Part")
part.Transparency = 0.5
part.Anchored = true
part.CanCollide = false
part.CastShadow = false

local function onCharacterCatching(character)
    local arm = character:WaitForChild('Left Arm')

    arm.ChildAdded:Connect(function(child)
        if not child:IsA("Weld") then return end
        isCatching = true
        task.wait(1.7)
        isCatching = false
    end)
end

workspace.ChildAdded:Connect(function(ball)
    if ball.Name ~= "Football" then return end
    if not ball:IsA("BasePart") then return end
    task.wait()

    local lastPosition = ball.Position
    local lastCheck = os.clock()
    local initalVelocity = ball.AssemblyLinearVelocity

    if (IS_SOLARA) and ball:FindFirstChildWhichIsA("Trail") and not ball.Anchored and camera.CameraSubject ~= ball then
        local fakeBall = ball:Clone()
        fakeBall.Name = "FFootball"
        fakeBall.Parent = workspace
        fakeBall.Anchored = true
        fakeBall.CanCollide = false
        fakeBall:FindFirstChildWhichIsA('PointLight'):Destroy()
        ball.Transparency = 1
        local spiralDegrees = 0
        fakeBalls[ball] = fakeBall
        task.spawn(function()
            while ball.Parent == workspace do
                local dt = runService.Heartbeat:Wait()
                spiralDegrees += 1500 * dt
                initalVelocity += Vector3.new(0, -28 * dt, 0)
                fakeBall.Position += initalVelocity * dt
                fakeBall.CFrame = CFrame.lookAt(fakeBall.Position, fakeBall.Position + initalVelocity) * CFrame.Angles(math.rad(90), math.rad(spiralDegrees), 0)

                if ball:FindFirstChildWhichIsA("Trail") then
                    ball:FindFirstChildWhichIsA("Trail").Enabled = false
                end
            end
            fakeBall:Destroy()
        end)
    end

    while ball.Parent do
        task.wait(0.1)

        local t = (os.clock() - lastCheck)
        velocity[ball] = (ball.Position - lastPosition) / t

        lastCheck = os.clock()
        lastPosition = ball.Position
    end
end)

task.spawn(function()
    while true do
        task.wait(1/60)
        local ball = findClosestBall(); if not ball then part.Parent = nil continue end
        local character = player.Character

        if not character then continue end

        local catchPart = getNearestPartToPartFromParts(ball, {character:FindFirstChild("CatchLeft"), character:FindFirstChild("CatchRight")})

        if not catchPart then continue end
        if not velocity[ball] then continue end
        if not magnetsMasterToggle.Value then continue end

        local currentMagnetsType = magnetsType.CurrentOption

        if currentMagnetsType == "League" then
            local predictedPosition = (fakeBalls[ball] or ball).Position + (velocity[ball] * ping)
            local distance = (catchPart.Position - predictedPosition).Magnitude

            part.Position = predictedPosition
            part.Size = Vector3.new(magnetsCustomRadius.Value, magnetsCustomRadius.Value, magnetsCustomRadius.Value)
            part.Parent = showMagHitbox.Value and workspace or nil

            if distance > magnetsCustomRadius.Value then continue end

            firetouchinterest(catchPart, ball, 0)
            firetouchinterest(catchPart, ball, 1)
        else
            local distance = (catchPart.Position - ball.Position).Magnitude
            local radius = ((currentMagnetsType == "Custom" and magnetsCustomRadius.Value) or currentMagnetsType == "Blatant" and 50 or 6)
            part.Position = (fakeBalls[ball] or ball).Position
            part.Size = Vector3.new(radius, radius, radius)
            part.Parent = showMagHitbox.Value and workspace or nil
            part.Color = Color3.fromRGB(173, 173, 173)

            if not isCatching and IS_SOLARA then continue end

            if distance < radius then
                firetouchinterest(catchPart, ball, 0)
                firetouchinterest(catchPart, ball, 1)
            end
        end
    end
end)

task.spawn(function()
    while true do
        task.wait()
        local ball = findClosestBall() if not ball then continue end
        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

        if not ball:FindFirstChildWhichIsA("Trail") then continue end
        if not character or not humanoidRootPart then continue end
        if not pullVectorMasterToggle.Value then continue end
        if pullVectoredBalls[ball] then continue end
        if ball.Anchored then continue end

        local distance = (humanoidRootPart.Position - ball.Position).Magnitude
        if distance > pullVectorDistance.Value then continue end

        local direction = (ball.Position - humanoidRootPart.Position).Unit

        if pullVectorType.CurrentOption == "Teleport" then
            pullVectoredBalls[ball] = true
            local distance = 10 + ((pullVectorPower.Value - 1) * 5)
            humanoidRootPart.CFrame += direction * distance
        else
            humanoidRootPart.AssemblyLinearVelocity = direction * pullVectorPower.Value * 25
        end
    end
end)

onCharacterCatching(player.Character)
player.CharacterAdded:Connect(onCharacterCatching)

-- PHYSICS SECTION

-- QuickTP Section
local QuickTPSection = PhysicsTab:CreateSection("Quick TP")

local quickTPToggle = PhysicsTab:CreateToggle({
    Name = "Quick TP",
    CurrentValue = false,
    Flag = "QuickTPToggle",
    Callback = function(Value) end
})

local quickTPSpeed = PhysicsTab:CreateSlider({
    Name = "Speed",
    Range = {1, 5},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 2.5,
    Flag = "QuickTPSpeed",
    Callback = function(Value) end
})

local quickTPBind = PhysicsTab:CreateKeybind({
    Name = "Keybind",
    CurrentKeybind = "F",
    Flag = "QuickTPBind",
    HoldToInteract = false,
    Callback = function(Keybind) end
})

-- ClickTackleAimbot Section
local ClickTackleSection = PhysicsTab:CreateSection("Click Tackle Aimbot")

local clickTackleAimbotToggle = PhysicsTab:CreateToggle({
    Name = "Click Tackle Aimbot",
    CurrentValue = false,
    Flag = "ClickTackleAimbotToggle",
    Callback = function(Value) end
})

local clickTackleAimbotDistance = PhysicsTab:CreateSlider({
    Name = "Distance",
    Range = {0, 15},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 7.5,
    Flag = "ClickTackleAimbotDistance",
    Callback = function(Value) end
})

-- Other Physics Toggles
local OtherPhysicsSection = PhysicsTab:CreateSection("Other Physics Features")

local antiJam = PhysicsTab:CreateToggle({
    Name = "Anti Jam",
    CurrentValue = false,
    Flag = "AntiJam",
    Callback = function(Value) end
})

local antiBlock = PhysicsTab:CreateToggle({
    Name = "Anti Block",
    CurrentValue = false,
    Flag = "AntiBlock",
    Callback = function(Value) end
})

local visualiseBallPath = PhysicsTab:CreateToggle({
    Name = "Visualise Ball Path",
    CurrentValue = false,
    Flag = "VisualiseBallPath",
    Callback = function(Value) end
})

local noJumpCooldown = PhysicsTab:CreateToggle({
    Name = "No Jump Cooldown",
    CurrentValue = false,
    Flag = "NoJumpCooldown",
    Callback = function(Value) end
})

local noFreeze = PhysicsTab:CreateToggle({
    Name = "No Freeze",
    CurrentValue = false,
    Flag = "NoFreeze",
    Callback = function(Value) end
})

-- OptimalJump Section
local OptimalJumpSection = PhysicsTab:CreateSection("Optimal Jump")

local optimalJumpPredictions = PhysicsTab:CreateToggle({
    Name = "Optimal Jump Predictions",
    CurrentValue = false,
    Flag = "OptimalJumpPredictions",
    Callback = function(Value) end
})

local optimalJumpType = PhysicsTab:CreateDropdown({
    Name = "Type",
    Options = {"Jump", "Dive"},
    CurrentOption = "Jump",
    Flag = "OptimalJumpType",
    Callback = function(Option) end
})

local noBallTrail = PhysicsTab:CreateToggle({
    Name = "No Ball Trail",
    CurrentValue = false,
    Flag = "NoBallTrail",
    Callback = function(Value) end
})

-- BigHead Section
local BigHeadSection = PhysicsTab:CreateSection("Big Head")

local bigHead = PhysicsTab:CreateToggle({
    Name = "Big Head",
    CurrentValue = false,
    Flag = "BigHead",
    Callback = function(Value) end
})

local bigHeadSize = PhysicsTab:CreateSlider({
    Name = "Size",
    Range = {1, 5},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 2,
    Flag = "BigHeadSize",
    Callback = function(Value) end
})

local function findPossessor()
    for index, player in pairs(players:GetPlayers()) do
        local character = player.Character; if not character then continue end
        if not character:FindFirstChildWhichIsA("Tool") then continue end
        return player.Character
    end
end

local boundaries = {}

if not IS_PRACTICE then
    for index, part in pairs(workspace.Models.Boundaries:GetChildren()) do
        boundaries[#boundaries + 1] = part
    end
end

local antiOOB = PhysicsTab:CreateToggle({
    Name = "Anti OOB",
    CurrentValue = false,
    Flag = "AntiOOB",
    Callback = function(Value)
        for index, boundary in pairs(boundaries) do
            boundary.Parent = not Value and workspace.Models.Boundaries or nil
        end
    end
})

if AC_BYPASS then
    local CFrameSpeedSection = PhysicsTab:CreateSection("CFrame Speed")

    local CFrameSpeedToggle = PhysicsTab:CreateToggle({
        Name = "CFrame Speed",
        CurrentValue = false,
        Flag = "CFrameSpeed",
        Callback = function(Value) end
    })

    local CFrameSpeedValue = PhysicsTab:CreateSlider({
        Name = "Speed",
        Range = {0, 10},
        Increment = 0.1,
        Suffix = "",
        CurrentValue = 2,
        Flag = "CFrameSpeedValue",
        Callback = function(Value) end
    })

    task.spawn(function()
        while true do task.wait();
            if not CFrameSpeedToggle.Value then continue end

            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
            local humanoid = character and character:FindFirstChild("Humanoid")

            if not humanoidRootPart or not humanoid then continue end

            local moveDirection = ((os.clock() - (moveToUsing[#moveToUsing] or 0)) < 0.5 and (humanoid.WalkToPoint - character.HumanoidRootPart.Position).Unit) or (humanoid.MoveDirection)

            humanoidRootPart.CFrame += moveDirection * (CFrameSpeedValue.Value / 58.5)
        end
    end)
end

if firetouchinterest and not IS_SOLARA then
    local TackleExtenderSection = PhysicsTab:CreateSection("Tackle Extender")

    local tackleExtender = PhysicsTab:CreateToggle({
        Name = "Tackle Extender",
        CurrentValue = false,
        Flag = "TackleExtender",
        Callback = function(Value) end
    })

    local tackleExtenderRadius = PhysicsTab:CreateSlider({
        Name = "Radius",
        Range = {0, 10},
        Increment = 0.1,
        Suffix = "",
        CurrentValue = 5,
        Flag = "TackleExtenderRadius",
        Callback = function(Value) end
    })

    task.spawn(function()
        while true do
            task.wait()

            local possessor = findPossessor()
            local character = player.Character
            local hrp = character and character:FindFirstChild("HumanoidRootPart")

            if not hrp then continue end
            if not possessor then continue end
            if not tackleExtender.Value then continue end

            local distance = (hrp.Position - possessor.HumanoidRootPart.Position).Magnitude

            if distance > tackleExtenderRadius.Value then continue end

            for index, part in pairs(possessor:GetChildren()) do
                if not part:IsA("BasePart") then continue end
                if not character:FindFirstChild(part.Name) then continue end
                firetouchinterest(character:FindFirstChild(part.Name), part, 0)
                firetouchinterest(character:FindFirstChild(part.Name), part, 1)
            end
        end
    end)
end

if AC_BYPASS then
    local BlockExtenderSection = PhysicsTab:CreateSection("Block Extender")

    local blockExtender = PhysicsTab:CreateToggle({
        Name = "Block Extender",
        CurrentValue = false,
        Flag = "BlockExtender",
        Callback = function(Value) end
    })

    local blockExtenderRange = PhysicsTab:CreateSlider({
        Name = "Range",
        Range = {1, 20},
        Increment = 0.1,
        Suffix = "",
        CurrentValue = 5,
        Flag = "BlockExtenderRange",
        Callback = function(Value) end
    })

    local blockExtenderRangeTransparency = PhysicsTab:CreateSlider({
        Name = "Transparency",
        Range = {0, 1},
        Increment = 0.01,
        Suffix = "",
        CurrentValue = 1,
        Flag = "BlockExtenderRangeTransparency",
        Callback = function(Value) end
    })

    local flying = false
    local flySpeed = 1

    local FlySection = PhysicsTab:CreateSection("Fly")

    local flyToggle = PhysicsTab:CreateToggle({
        Name = "Fly",
        CurrentValue = false,
        Flag = "Fly",
        Callback = function(Value)
            flying = Value

            if Value then
                player.Character.Humanoid.PlatformStand = true
                local bodyVelocity = Instance.new("BodyVelocity", player.Character.HumanoidRootPart)
                local camera = workspace.CurrentCamera
                bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                local bodyGyro = Instance.new("BodyGyro", player.Character.HumanoidRootPart)
                bodyGyro.P = 15000
                bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                while flying do
                    runService.Stepped:wait()
                    local speed = 11 + (flySpeed * 2.5)
                    local endPos = camera.CFrame.Position + camera.CFrame.LookVector * 500
                    bodyGyro.CFrame = CFrame.new(player.Character.HumanoidRootPart.Position, endPos)
                    local velocity = Vector3.new(0, 0, 0)
                    if not userInputService:GetFocusedTextBox() then
                        if userInputService:IsKeyDown(Enum.KeyCode.W) then
                            velocity += camera.CFrame.LookVector * speed
                        end
                        if userInputService:IsKeyDown(Enum.KeyCode.S) then
                            velocity += camera.CFrame.LookVector * -speed
                        end
                        if userInputService:IsKeyDown(Enum.KeyCode.A) then
                            velocity += player.Character.HumanoidRootPart.CFrame:vectorToWorldSpace(Vector3.new(-speed, 0, 0))
                        end
                        if userInputService:IsKeyDown(Enum.KeyCode.D) then
                            velocity += player.Character.HumanoidRootPart.CFrame:vectorToWorldSpace(Vector3.new(speed, 0, 0))
                        end
                    end
                    if player.Character.Humanoid.Health <= 0 then
                        flying = false
                    end
                    bodyVelocity.Velocity = velocity
                end
                player.Character.Humanoid.PlatformStand = false
                bodyGyro:Destroy()
                bodyVelocity:Destroy()
            end
        end
    })

    local flySpeedSlider = PhysicsTab:CreateSlider({
        Name = "Fly Speed",
        Range = {1, IS_PRACTICE and 20 or 5},
        Increment = 0.1,
        Suffix = "",
        CurrentValue = 2,
        Flag = "FlySpeed",
        Callback = function(Value)
            flySpeed = Value
        end
    })

    task.spawn(function()
        while true do
            task.wait()

            local character = player.Character
            local blockPart = character and character:FindFirstChild("BlockPart")

            if not blockPart then continue end

            blockPart.Size = blockExtender.Value and Vector3.new(blockExtenderRange.Value, blockExtenderRange.Value, blockExtenderRange.Value) or Vector3.new(0.75, 5, 1.5)
            blockPart.Transparency = blockExtender.Value and blockExtenderRangeTransparency.Value or 1
        end
    end)
end

local function onCharacterPhysics(char)
    local humanoid = char:WaitForChild("Humanoid")

    char.DescendantAdded:Connect(function(v)
        task.wait()
        if v.Name:match("FFmover") and antiBlock.Value then
            v:Destroy()
        end
    end)

    task.spawn(function()
        while true do
            task.wait()
            if noJumpCooldown.Value then
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
            end

            local torso = char:FindFirstChild("Torso")
            local head = char:FindFirstChild("Head")

            if not torso or not head then return end

            if humanoid:GetState() == Enum.HumanoidStateType.Running and values.Status.Value == "InPlay" then
                torso.CanCollide = not antiJam.Value
                head.CanCollide = not antiJam.Value
            else
                torso.CanCollide = true
                head.CanCollide = true
            end
        end
    end)
end

task.spawn(function()
    local function applyChanges(character)
        local head = character and character:FindFirstChild("Head")
        local mesh = head and head:FindFirstChildWhichIsA("SpecialMesh")

        if not mesh then return end

        mesh.MeshType = bigHead.Value and Enum.MeshType.Sphere or Enum.MeshType.Head
        head.Size = bigHead.Value and Vector3.new(bigHeadSize.Value, 1, bigHeadSize.Value) or Vector3.new(2, 1, 1)
    end

    while true do
        task.wait()

        for index, player in pairs(players:GetPlayers()) do
            if player == players.LocalPlayer then continue end
            applyChanges(player.Character)
        end
    end
end)

workspace.ChildAdded:Connect(function(ball)
    task.wait()
    if ball.Name ~= "Football" then return end
    if not ball:IsA("BasePart") then return end

    if noBallTrail.Value and ball:FindFirstChildWhichIsA("Trail") then
        ball:FindFirstChildWhichIsA("Trail").Enabled = false
    end

    task.spawn(function()
        if not optimalJumpPredictions.Value then return end
        local initalVelocity = ball.AssemblyLinearVelocity
        local optimalPosition = Vector3.zero

        local currentPosition = ball.Position

        local t = 0

        while true do
            t += 0.05
            initalVelocity += Vector3.new(0, -28 * 0.05, 0)
            currentPosition += initalVelocity * 0.05
            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {workspace:FindFirstChild("Models")}
            raycastParams.FilterType = Enum.RaycastFilterType.Include

            local ray = workspace:Raycast(currentPosition, Vector3.new(0, optimalJumpType.CurrentOption == "Jump" and -13 or -15, 0), raycastParams)
            local antiCrashRay = workspace:Raycast(currentPosition, Vector3.new(0, -500, 0), raycastParams)

            if ray and t > 0.75 then
                optimalPosition = ray.Position + Vector3.new(0, 2, 0)
                break
            end

            if not antiCrashRay then
                optimalPosition = currentPosition
                break
            end
        end

        local part = Instance.new("Part")
        part.Anchored = true
        part.Material = Enum.Material.Neon
        part.Size = Vector3.new(1.5, 1.5, 1.5)
        part.Position = optimalPosition
        part.CanCollide = false
        part.Parent = workspace

        repeat task.wait() until ball.Parent ~= workspace

        part:Destroy()
    end)

    task.spawn(function()
        if not visualiseBallPath.Value then return end
        local initalVelocity = ball.AssemblyLinearVelocity
        local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment")
        a0.Parent = workspace.Terrain; a1.Parent = workspace.Terrain

        local beam = Instance.new("Beam", workspace.Terrain)
        beam.Attachment0 = a0
        beam.Attachment1 = a1
        beam.Segments = 500
        beam.Width0 = 0.5
        beam.Width1 = 0.5
        beam.Transparency = NumberSequence.new(0)
        beam.Color = ColorSequence.new(Color3.fromHex("#FF8EA5"))

        local g = Vector3.new(0, -28 ,0)
        local x0 = ball.Position
        local v0 = initalVelocity

        local curve0, curve1, cf1, cf2 = beamProjectile(g, v0, x0, 5)

        beam.CurveSize0 = curve0
        beam.CurveSize1 = curve1
        a0.CFrame = a0.Parent.CFrame:inverse() * cf1
        a1.CFrame = a1.Parent.CFrame:inverse() * cf2

        repeat task.wait() until ball.Parent ~= workspace

        beam:Destroy()
    end)
end)

local quickTPCooldown = os.clock()

userInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode ~= Enum.KeyCode[quickTPBind.Value] then return end

    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    local humanoid = character and character:FindFirstChild("Humanoid")

    if not quickTPToggle.Value then return end
    if not character or not humanoidRootPart or not humanoid then return end
    if (os.clock() - quickTPCooldown) < 0.1 then return end

    local speed = 2 + (quickTPSpeed.Value / 4)

    humanoidRootPart.CFrame += humanoid.MoveDirection * speed
    quickTPCooldown = os.clock()
end)

mouse.Button1Down:Connect(function()
    if not clickTackleAimbotToggle.Value then return end

    local possessor = findPossessor()
    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not character or not humanoidRootPart then return end
    if not possessor then return end

    local distance = (possessor.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
    if distance > clickTackleAimbotDistance.Value then return end

    humanoidRootPart.CFrame = possessor.HumanoidRootPart.CFrame
end)

onCharacterPhysics(player.Character)
player.CharacterAdded:Connect(onCharacterPhysics)

-- THROWING SECTION

-- Create QBAimbot Section
local QBAimbotSection = ThrowingTab:CreateSection("QB Aimbot")

local QBAimbot = ThrowingTab:CreateToggle({
    Name = "QB Aimbot",
    CurrentValue = false,
    Flag = "QBAimbot",
    Callback = function(Value) end
})

local QBAimbotUI = ThrowingTab:CreateToggle({
    Name = "UI",
    CurrentValue = true,
    Flag = "QBAimbotUI",
    Callback = function(Value) end
})

local QBAimbotVisualise = ThrowingTab:CreateToggle({
    Name = "Visualise",
    CurrentValue = true,
    Flag = "QBAimbotVisualise",
    Callback = function(Value) end
})

local QBAimbotAutoAngle = ThrowingTab:CreateToggle({
    Name = "Auto Angle",
    CurrentValue = false,
    Flag = "QBAimbotAutoAngle",
    Callback = function(Value) end
})

local QBAimbotAutoThrowType = ThrowingTab:CreateToggle({
    Name = "Auto Throw Type",
    CurrentValue = false,
    Flag = "QBAimbotAutoThrowType",
    Callback = function(Value) end
})

local QBAimbot95PowerOnly = ThrowingTab:CreateToggle({
    Name = "95 Power Only",
    CurrentValue = false,
    Flag = "QBAimbot95PowerOnly",
    Callback = function(Value) end
})

local QBAimbotAntiOOB = ThrowingTab:CreateToggle({
    Name = "Anti OOB",
    CurrentValue = false,
    Flag = "QBAimbotAntiOOB",
    Callback = function(Value) end
})

local QBAimbotAntiOOBThreshold = ThrowingTab:CreateSlider({
    Name = "Anti OOB Threshold",
    Range = {-10, 10},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 0,
    Flag = "QBAimbotAntiOOBThreshold",
    Callback = function(Value) end
})

local QBAimbotXOffset = ThrowingTab:CreateSlider({
    Name = "X Offset",
    Range = {-5, 5},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 0,
    Flag = "QBAimbotXOffset",
    Callback = function(Value) end
})

local QBAimbotYOffset = ThrowingTab:CreateSlider({
    Name = "Y Offset",
    Range = {-5, 5},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 0,
    Flag = "QBAimbotYOffset",
    Callback = function(Value) end
})

-- Keybind Section
local KeybindSection = ThrowingTab:CreateSection("Throw Type Keybinds")

local QBAimbotDimeKeybind = ThrowingTab:CreateKeybind({
    Name = "Dime Bind",
    CurrentKeybind = "One",
    Flag = "QBAimbotDimeKeybind",
    HoldToInteract = false,
    Callback = function(Keybind) end
})

local QBAimbotJumpKeybind = ThrowingTab:CreateKeybind({
    Name = "Jump Bind",
    CurrentKeybind = "Two",
    Flag = "QBAimbotJumpKeybind",
    HoldToInteract = false,
    Callback = function(Keybind) end
})

local QBAimbotBulletKeybind = ThrowingTab:CreateKeybind({
    Name = "Bullet Bind",
    CurrentKeybind = "Three",
    Flag = "QBAimbotBulletKeybind",
    HoldToInteract = false,
    Callback = function(Keybind) end
})

local QBAimbotDiveKeybind = ThrowingTab:CreateKeybind({
    Name = "Dive Bind",
    CurrentKeybind = "Four",
    Flag = "QBAimbotDiveKeybind",
    HoldToInteract = false,
    Callback = function(Keybind) end
})

local QBAimbotMagKeybind = ThrowingTab:CreateKeybind({
    Name = "Mag Bind",
    CurrentKeybind = "Five",
    Flag = "QBAimbotMagKeybind",
    HoldToInteract = false,
    Callback = function(Keybind) end
})

-- Other Settings
local OtherQBSettingsSection = ThrowingTab:CreateSection("Other QB Settings")

local QBAimbotExperimental = ThrowingTab:CreateToggle({
    Name = "Experimental",
    CurrentValue = true,
    Flag = "QBAimbotExperimental",
    Callback = function(Value) end
})

local QBAimbotAdjustPowerGUI = ThrowingTab:CreateToggle({
    Name = "Adjust Power GUI",
    CurrentValue = false,
    Flag = "QBAimbotAdjustPowerGUI",
    Callback = function(Value) end
})

-- Trajectory Section
local TrajectorySection = ThrowingTab:CreateSection("Trajectory")

local trajectory = ThrowingTab:CreateToggle({
    Name = "Trajectory",
    CurrentValue = false,
    Flag = "Trajectory",
    Callback = function(Value) end
})

local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment")
a0.Parent = workspace.Terrain; a1.Parent = workspace.Terrain

local beam = Instance.new("Beam", workspace.Terrain)
beam.Attachment0 = a0
beam.Attachment1 = a1
beam.Segments = 500
beam.Width0 = 0.5
beam.Width1 = 0.5
beam.Transparency = NumberSequence.new(0)
beam.Color = ColorSequence.new(Color3.fromHex("#EBAFCC"))

local function findTarget(opp)
    local cc = workspace.CurrentCamera
    local target = nil
    local dist = math.huge

    local targets = {}

    for index, player in pairs(players:GetPlayers()) do
        if not opp then
            if players.LocalPlayer.Team and (players.LocalPlayer.Team ~= player.Team) then continue end
        else
            if players.LocalPlayer.Team and (players.LocalPlayer.Team == player.Team) then continue end
        end
        targets[#targets + 1] = player.Character
    end

    if IS_PRACTICE then
        targets[#targets + 1] = workspace.npcwr.a['bot 1']
        targets[#targets + 1] = workspace.npcwr.a['bot 2']
        targets[#targets + 1] = workspace.npcwr.b['bot 3']
        targets[#targets + 1] = workspace.npcwr.b['bot 4']
    end

    for i,v in pairs(targets) do
        local screenpoint,onscreen = cc:WorldToViewportPoint(v.HumanoidRootPart.Position)
        local check = (Vector2.new(userInputService:GetMouseLocation().X,userInputService:GetMouseLocation().Y)-Vector2.new(screenpoint.X,screenpoint.Y)).magnitude
        if check < dist then
            target = v
            dist = check
        end
    end

    return target
end

task.spawn(function()
    while true do
        task.wait()
        local ballGui = player.PlayerGui:FindFirstChild("BallGui")
        local character = player.Character

        local head = character and character:FindFirstChild("Head")

        if not character or not head then continue end
        if not ballGui then beam.Parent = nil continue end
        if not trajectory.Value then beam.Parent = nil continue end

        beam.Parent = workspace.Terrain

        local power = tonumber(ballGui:FindFirstChild("Disp", true).Text)
        local direction = (mouse.Hit.Position - camera.CFrame.Position).Unit

        local origin = head.Position + direction * 5
        local curve0, curve1, cf1, cf2 = beamProjectile(Vector3.new(0, -28, 0), power * direction, origin, 10);

        beam.CurveSize0 = curve0
        beam.CurveSize1 = curve1

        a0.CFrame = a0.Parent.CFrame:inverse() * cf1
        a1.CFrame = a1.Parent.CFrame:inverse() * cf2
    end
end)

-- QB Aimbot Implementation
task.spawn(function()
    local target = nil
    local power = 65
    local direction = Vector3.new(0, 1, 0)
    local angle = 45
    local locked = false

    local firedRemoteEvent = false

    local within = table.find

    local throwType = "Dive"
    local nonVisualThrowType = nil

    local throwTypesSwitch = {
        ["Dive"] = "Mag",
        ["Mag"] = "Bullet",
        ["Bullet"] = "Jump",
        ["Jump"] = "Dime",
        ["Dime"] = "Dive"
    }

    local moveDirection = {}

    local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment")
    a0.Parent = workspace.Terrain; a1.Parent = workspace.Terrain

    local beam = Instance.new("Beam", workspace.Terrain)
    beam.Attachment0 = a0
    beam.Attachment1 = a1
    beam.Segments = 500
    beam.Width0 = 0.5
    beam.Width1 = 0.5
    beam.Transparency = NumberSequence.new(0)
    beam.Color = ColorSequence.new(Color3.fromHex("#EBAFCC"))

    local cards = game:GetObjects("rbxassetid://18241514541")[1]:Clone()
    cards.Parent = (gethui and gethui()) or game:GetService("CoreGui")
    cards.Enabled = false

    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromHex("#6a64a2")
    highlight.Parent = replicatedStorage

    local part = Instance.new("Part")
    part.Parent = workspace
    part.Anchored = true
    part.CanCollide = false

    local inbPart = Instance.new("Part")
    inbPart.CanCollide = false
    inbPart.Anchored = true
    inbPart.Transparency = 1
    inbPart.Position = IS_PRACTICE and Vector3.new(245, 40.55, 0) or Vector3.new(0, 40.55, 0)
    inbPart.Size = Vector3.new(161, 75, 360)
    inbPart.Parent = workspace

    local keys = {
        R = function()
            angle = math.clamp(angle + 5, 5, 85)
        end,
        F = function()
            angle = math.clamp(angle - 5, 5, 85)
        end,
        Q = function()
            locked = not locked
        end,
        Z = function()
            throwType = throwTypesSwitch[throwType]
        end,
    }

    -- input handling
    userInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if not keys[input.KeyCode.Name] then return end

        keys[input.KeyCode.Name]()
    end)

    userInputService.InputBegan:Connect(function(input, gp)
        if gp then return end

        if QBAimbotDimeKeybind.Value == input.KeyCode then
            throwType = "Dime"
        end

        if QBAimbotJumpKeybind.Value == input.KeyCode then
            throwType = "Jump"
        end

        if QBAimbotDiveKeybind.Value == input.KeyCode then
            throwType = "Dive"
        end

        if QBAimbotMagKeybind.Value == input.KeyCode then
            throwType = "Mag"
        end

        if QBAimbotBulletKeybind.Value == input.KeyCode then
            throwType = "Bullet"
        end
    end)

    --// functions

    local function getTimeForHeight(from, to, height)
        local g = Vector3.new(0, -28, 0)
        local conversionFactor = 4
        local xMeters = height * conversionFactor

        local a = 0.5 * g.Y
        local b = to.Y - from.Y
        local c = xMeters - from.Y

        local discriminant = b * b - 4 * a * c
        if discriminant < 0 then
            return nil
        end

        local t1 = (-b + math.sqrt(discriminant)) / (2 * a)
        local t2 = (-b - math.sqrt(discriminant)) / (2 * a)

        local t = math.max(t1, t2)
        return t
    end

    local function clamp_oobPosition(position)
        inbPart.Size = Vector3.new(161 + (QBAimbotAntiOOBThreshold.Value * 2), 75, 360 + (QBAimbotAntiOOBThreshold.Value * 2))
        return Vector3.new(
            math.clamp(position.X, -inbPart.Size.X / 2 + inbPart.Position.X, inbPart.Size.X / 2 + inbPart.Position.X),
            math.clamp(position.Y, -inbPart.Size.Y / 2, inbPart.Size.Y / 2),
            math.clamp(position.Z, -inbPart.Size.Z / 2 + inbPart.Position.Z, inbPart.Size.Z / 2 + inbPart.Position.Z)
        )
    end

    local function getVelocityForXYinTime(from, to, time)
        local g = Vector3.new(0, -28, 0)
        local v0 = (to - from - 0.5*g*time*time)/time;
        local dir = ((from + v0) - from).Unit
        local power = v0.Y / dir.Y
        return v0, dir, math.clamp(math.round(power), 0, 95)
    end

    local function getVelocityForAngle(from, to, angle, standingStill)
        local yMult = standingStill and
            angle / 90 / ((angle > 65 and 1 - (angle - 70) / 25) or (angle > 50 and 1.6 - (angle - 55) / 50) or (angle > 40 and 1.9) or (angle > 30 and 2.25) or (angle > 15 and 2.5) or 3)
            or angle / 90 / ((angle > 70 and 0.55 - ( (angle - 60) / 30 ) * 0.45) or (angle > 60 and 0.8 - ( (angle - 60) / 30 ) * 0.45) or (angle > 53 and 1) or (angle > 43 and 1.2) or (angle > 30 and 1.5) or 1.9)

        local distance = (from - to).Magnitude
        local height = yMult * distance

        local t = getTimeForHeight(from, to, height)
        local velocity = getVelocityForXYinTime(from, to, t)

        return velocity, t
    end

    local function finalCalc(char, angle, xLead, yLead, sideways)
        xLead = xLead or 0

        local IS_PLAYER = players:GetPlayerFromCharacter(char)
        local moveDirection = IS_PLAYER and ((not sideways and QBAimbotExperimental.Value and moveDirection[char]) or char.Humanoid.MoveDirection) or (char.Humanoid.WalkToPoint - char.HumanoidRootPart.Position).Unit
        local _, t = getVelocityForAngle(player.Character.Head.Position, char.HumanoidRootPart.Position, angle, moveDirection.Magnitude <= 0)

        local pos = char.Head.Position + (moveDirection * 20 * t) + (moveDirection * xLead) + (moveDirection * 20 * ping) + Vector3.new(0, yLead, 0)

        pos = QBAimbotAntiOOB.Value and clamp_oobPosition(pos) or pos

        return getVelocityForXYinTime(player.Character.Head.Position, pos, t), pos, t
    end

    local function checkIfInterceptable(position, time)
        local blacklist = {}
        local interceptable = false

        blacklist[target.Name] = true

        if player.Team then
            for index, player in pairs(player.Team:GetPlayers()) do
                blacklist[player.Name] = true
            end
        end

        local targets = {}

        for index, player in pairs(players:GetPlayers()) do
            targets[#targets + 1] = player.Character
        end

        if IS_PRACTICE then
            targets[#targets + 1] = workspace.npcwr.a['bot 1']
            targets[#targets + 1] = workspace.npcwr.a['bot 2']
            targets[#targets + 1] = workspace.npcwr.b['bot 3']
            targets[#targets + 1] = workspace.npcwr.b['bot 4']
        end

        for index, character in pairs(targets) do
            if blacklist[character.Name] then continue end
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

            if not humanoidRootPart then continue end

            local distance = (humanoidRootPart.Position - position).Magnitude
            local radius = (20 * time) + 7.5

            interceptable = distance < radius
            if interceptable then break end
        end

        return interceptable
    end

    local function getPosInXTimeFromVel(initialPos, initialVelocity, gravity, time)
        local position = initialPos + initialVelocity * time + 0.5 * gravity * time * time
        return position
    end

    local function findRoute(character)
        local isPlayer = players:GetPlayerFromCharacter(character)

        local moveDirection = isPlayer and character.Humanoid.MoveDirection or (character.Humanoid.WalkToPoint - character.HumanoidRootPart.Position).Unit
        local distance = (character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude

        local function isDiagonal()
            local absMD = Vector3.new(math.abs(moveDirection.X), 0, math.abs(moveDirection.Z))
            local diff = (absMD - Vector3.new(0.7, 0, 0.7)).Magnitude
            return diff < 0.5
        end

        local function isSideways()
            local direction = (character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Unit
            local highest = math.abs(direction.X) > math.abs(direction.Z) and "Z" or "X"
            return math.abs(moveDirection[highest]) > 0.8
        end

        local function towardsQB()
            local newDistance = ((character.HumanoidRootPart.Position + (moveDirection * 16)) - player.Character.HumanoidRootPart.Position).Magnitude
            return (distance - newDistance) > 12
        end

        local requirements = {
            ["go"] = function()
                return not isDiagonal() and not towardsQB()
            end,
            ["post/corner"] = function()
                return isDiagonal() and not towardsQB() and distance > 125
            end,
            ["slant"] = function()
                return isDiagonal() and not towardsQB() and distance <= 125
            end,
            ["in/out"] = function()
                return isSideways() and distance > 125
            end,
            ["flat"] = function()
                return isSideways() and distance <= 125
            end,
            ["curl/comeback"] = function()
                return towardsQB()
            end,
            ["stationary"] = function()
                return moveDirection.Magnitude <= 0
            end,
        }

        local route = nil

        for routeName, func in pairs(requirements) do
            route = func() and routeName or route
            if route then break end
        end

        return route, moveDirection
    end

    local sidewayRoutes = {"in/out", "flat"}
    local inAirAdditiveRoutes = {"stationary", "curl/comeback"}

    local offsets = {
        Dive = {
            xLead = 3,
            yLead = 4.5,
            routes = {
                ["go"] = {
                    xzOffset = 0,
                    yOffset = 0
                },
                ["post/corner"] = {
                    xzOffset = 0,
                    yOffset = 0
                },
                ["slant"] = {
                    xzOffset = 0,
                    yOffset = 0
                },
                ["in/out"] = {
                    xzOffset = -1,
                    yOffset = -2
                },
                ["flat"] = {
                    xzOffset = 0,
                    yOffset = -2
                },
                ["curl/comeback"] = {
                    xzOffset = 4,
                    yOffset = 0
                },
                ["stationary"] = {
                    xzOffset = 0,
                    yOffset = 0
                }
            }
        },
        Mag = {
            xLead = 3,
            yLead = 6,
            routes = {
                ["go"] = {
                    xzOffset = 0,
                    yOffset = 0
                },
                ["post/corner"] = {
                    xzOffset = 0,
                    yOffset = 0
                },
                ["slant"] = {
                    xzOffset = 0,
                    yOffset = 0
                },
                ["in/out"] = {
                    xzOffset = -1,
                    yOffset = -2
                },
                ["flat"] = {
                    xzOffset = 0,
                    yOffset = -2
                },
                ["curl/comeback"] = {
                    xzOffset = 6,
                    yOffset = 0
                },
                ["stationary"] = {
                    xzOffset = 0,
                    yOffset = 0
                }
            }
        },
        Jump = {
            xLead = 2,
            yLead = 3,
            routes = {
                ["go"] = {
                    xzOffset = 0,
                    yOffset = -1.5
                },
                ["post/corner"] = {
                    xzOffset = 0,
                    yOffset = 0
                },
                ["slant"] = {
                    xzOffset = 0,
                    yOffset = 0
                },
                ["in/out"] = {
                    xzOffset = -1,
                    yOffset = 3
                },
                ["flat"] = {
                    xzOffset = 0,
                    yOffset = 3
                },
                ["curl/comeback"] = {
                    xzOffset = 2,
                    yOffset = 4
                },
                ["stationary"] = {
                    xzOffset = 0,
                    yOffset = 7.5
                }
            }
        },
        Dime = {
            xLead = 2,
            routes = {
                ["go"] = {
                    xzOffset = 0,
                    yOffset = 0
                },
                ["post/corner"] = {
                    xzOffset = 0,
                    yOffset = 0
                },
                ["slant"] = {
                    xzOffset = 0,
                    yOffset = 0
                },
                ["in/out"] = {
                    xzOffset = -1,
                    yOffset = -1
                },
                ["flat"] = {
                    xzOffset = 0,
                    yOffset = -1
                },
                ["curl/comeback"] = {
                    xzOffset = 2,
                    yOffset = 0
                },
                ["stationary"] = {
                    xzOffset = 0,
                    yOffset = 0
                }
            }
        },
    }

    local function determineAutoThrowType(route)
        if not target then return end

        local IS_PLAYER = players:GetPlayerFromCharacter(target)
        local dbDistance = math.huge

        for index, player in pairs(players:GetPlayers()) do
            if IS_PLAYER and IS_PLAYER.Team and IS_PLAYER.Team == player.Team then continue end
            if IS_PLAYER and player == IS_PLAYER then continue end

            local character = player.Character
            local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

            if not humanoidRootPart then continue end

            local distance = (humanoidRootPart.Position - target.HumanoidRootPart.Position).Magnitude

            if distance < dbDistance then
                dbDistance = distance
            end
        end

        local forwardRoutes = {"go", "post/corner", "slant", "curl/comeback", "stationary"}
        local sidewayRoutes = {"in/out", "flat"}

        if within(forwardRoutes, route) then
            if dbDistance > 5 then
                return (QBAimbot95PowerOnly.Value or angle < 40) and "Jump" or "Dime"
            elseif dbDistance > 2 then
                return "Dive"
            end

            return "Mag"
        elseif within(sidewayRoutes, route) then
            if dbDistance > 4 then
                return "Dime"
            end

            return "Jump"
        end

        return "Dime"
    end

    local function determine95PowerOnlyAngle(distance, route)
        local IN_AIR = player.Character.Humanoid.FloorMaterial == Enum.Material.Air

        local autoAngleFunc = {
            ["go"] = function()
                return distance > 150 and math.max(IN_AIR and (16 + math.max(distance - 100, 0) / 5) or (14 + math.max(distance - 100, 0) / 5), 25)
                    or (IN_AIR and 16.5 + math.max(distance, 0) * (12.5 / 150) or 14 + math.max(distance, 0) * (12.5 / 150))
            end,
            ["in/out"] = function()
                return 10 + math.max((distance - 100), 0) / 10
            end,
            ["flat"] = function()
                return 10 + math.max((distance - 100), 0) / 10
            end,
            ["curl/comeback"] = function()
                return 7.5 + math.max((distance - 100), 0) / 20
            end,
            ["stationary"] = function()
                return 13.5 + math.max((distance - 100), 0) / 20
            end,
        }

        return (autoAngleFunc[route] or autoAngleFunc.go)()
    end
end)

-- Continue code for QB Aimbot implementation
local function determineAutoAngle(distance, route)
    local autoAngleFunc = {
        ["go"] = function()
            return math.min(25 + (distance / 10), 40)
        end,
        ["in/out"] = function()
            return 10 + math.max((distance - 100), 0) / 10
        end,
        ["flat"] = function()
            return 10 + math.max((distance - 100), 0) / 10
        end,
        ["curl/comeback"] = function()
            return 7.5 + math.max((distance - 100), 0) / 20
        end,
        ["stationary"] = function()
            return 17 + math.max((distance - 100), 0) / 20
        end,
    }

    return (autoAngleFunc[route] or autoAngleFunc.go)()
end

local function findClosestMultiple(x, y)
    local m = math.round(y / x)
    return m * x
end

local function changePowerGui(power)
    local ballGui = player.PlayerGui:FindFirstChild("BallGui")
    if ballGui then
        for index, frame in pairs(ballGui['Frame0']:GetChildren()) do
            if frame.Name == "Disp" then continue end
            frame.BackgroundTransparency = tonumber(frame.Name) <= power and 0 or 0.9
        end
    end

    ballGui['Frame0'].Disp.Text = power
end

task.spawn(function()
    local moveDirectionData = {}

    while true do task.wait(1/30);
        for index, player in pairs(players:GetPlayers()) do
            local character = player.Character
            local humanoid = character and character:FindFirstChild("Humanoid")

            if not humanoid then continue end

            if not moveDirectionData[character] then
                moveDirectionData[character] = {
                    Direction = humanoid.MoveDirection,
                    Started = os.clock()
                }
                moveDirection[character] = humanoid.MoveDirection
            end

            local newMoveDirection = humanoid.MoveDirection

            if (newMoveDirection - moveDirectionData[character].Direction).Magnitude > 0.2 then
                moveDirectionData[character] = {
                    Direction = humanoid.MoveDirection,
                    Started = os.clock()
                }
            else
                if (os.clock() - moveDirectionData[character].Started) > 0.5 then
                    moveDirection[character] = humanoid.MoveDirection
                    moveDirectionData[character] = {
                        Direction = humanoid.MoveDirection,
                        Started = os.clock()
                    }
                end
            end
        end
    end
end)

-- VISUALS SECTION
local CameraZoomSection = VisualsTab:CreateSection("Camera Zoom")

local cameraZoom = VisualsTab:CreateToggle({
    Name = "Camera Zoom",
    CurrentValue = false,
    Flag = "CameraZoom",
    Callback = function(Value)
        player.CameraMaxZoomDistance = not Value and 50 or player.CameraMaxZoomDistance
    end
})

local cameraZoomDistance = VisualsTab:CreateSlider({
    Name = "Distance",
    Range = {0, 1000},
    Increment = 1,
    Suffix = "",
    CurrentValue = player.CameraMaxZoomDistance,
    Flag = "CameraZoomDistance",
    Callback = function(Value)
        player.CameraMaxZoomDistance = cameraZoom.Value and Value or 50
    end
})

local NoRenderSection = VisualsTab:CreateSection("No Render")

local function toggleRenderingTextures(v)
    if childAddedEvent then
        childAddedEvent:Disconnect()
        childAddedEvent = nil
    end

    if not v then
        for index, part in pairs(workspace:GetDescendants()) do
            if not part:IsA("BasePart") then continue end
            part:SetAttribute("originalMaterial", part.Material.Name)
            part.Material = Enum.Material.SmoothPlastic
        end

        childAddedEvent = workspace.DescendantAdded:Connect(function(part)
            if not part:IsA("BasePart") then return end
            part:SetAttribute("originalMaterial", part.Material.Name)
            part.Material = Enum.Material.SmoothPlastic
        end)
    else
        for index, part in pairs(workspace:GetDescendants()) do
            if not part:IsA("BasePart") then continue end
            if not part:GetAttribute("originalMaterial") then continue end
            part.Material = Enum.Material[part:GetAttribute("originalMaterial")]
        end
    end
end

local noRender = VisualsTab:CreateToggle({
    Name = "No Render",
    CurrentValue = false,
    Flag = "NoRender",
    Callback = function(Value) end
})

local textures = VisualsTab:CreateToggle({
    Name = "Textures",
    CurrentValue = false,
    Flag = "Textures",
    Callback = function(Value)
        repeat task.wait() until noRender.Value or textures.Value ~= Value
        toggleRenderingTextures(not Value)
    end
})

local SilentModeSection = VisualsTab:CreateSection("Silent Mode")

local SilentMode = VisualsTab:CreateToggle({
    Name = "Silent Mode",
    CurrentValue = false,
    Flag = "SilentMode",
    Callback = function(Value) end
})

-- AUTOMATICS SECTION

-- Create Guard UI
local guardUI = game:GetObjects("rbxassetid://18271144228")[1]:Clone()
guardUI.Parent = (gethui and gethui()) or game:GetService("CoreGui")
guardUI.Enabled = false

local guardHighlight = Instance.new("Highlight")
guardHighlight.FillColor = Color3.fromRGB(173, 173, 173)
guardHighlight.Parent = replicatedStorage

-- AutoQB Section
local AutoQBSection = AutomaticsTab:CreateSection("Auto QB")

local autoQB = AutomaticsTab:CreateToggle({
    Name = "Auto QB",
    CurrentValue = false,
    Flag = "AutoQB",
    Callback = function(Value) end
})

local autoQBType = AutomaticsTab:CreateDropdown({
    Name = "Type",
    Options = {"Blatant", "Legit"},
    CurrentOption = "Blatant",
    Flag = "AutoQBType",
    Callback = function(Option) end
})

-- AutoCaptain Section
local AutoCaptainSection = AutomaticsTab:CreateSection("Auto Captain")

local autoCaptain = AutomaticsTab:CreateToggle({
    Name = "Auto Captain",
    CurrentValue = false,
    Flag = "AutoCaptain",
    Callback = function(Value) end
})

local finishLine = not IS_PRACTICE and workspace.Models.LockerRoomA.FinishLine or Instance.new('Part')

-- AutoCatch Section
local AutoCatchSection = AutomaticsTab:CreateSection("Auto Catch")

local autoCatch = AutomaticsTab:CreateToggle({
    Name = "Auto Catch",
    CurrentValue = false,
    Flag = "AutoCatch",
    Callback = function(Value) end
})

local autoCatchRadius = AutomaticsTab:CreateSlider({
    Name = "Radius",
    Range = {0, 50},
    Increment = 1,
    Suffix = "",
    CurrentValue = 10,
    Flag = "AutoCatchRadius",
    Callback = function(Value) end
})

-- AutoSwat Section
local AutoSwatSection = AutomaticsTab:CreateSection("Auto Swat")

local autoSwat = AutomaticsTab:CreateToggle({
    Name = "Auto Swat",
    CurrentValue = false,
    Flag = "AutoSwat",
    Callback = function(Value) end
})

local autoSwatRadius = AutomaticsTab:CreateSlider({
    Name = "Radius",
    Range = {0, 50},
    Increment = 1,
    Suffix = "",
    CurrentValue = 10,
    Flag = "AutoSwatRadius",
    Callback = function(Value) end
})

-- AutoKicker Section
local AutoKickerSection = AutomaticsTab:CreateSection("Auto Kicker")

local autoKicker = AutomaticsTab:CreateToggle({
    Name = "Auto Kicker",
    CurrentValue = false,
    Flag = "AutoKicker",
    Callback = function(Value) end
})

local autoKickerPower = AutomaticsTab:CreateSlider({
    Name = "Power",
    Range = {0, 100},
    Increment = 1,
    Suffix = "",
    CurrentValue = 100,
    Flag = "AutoKickerPower",
    Callback = function(Value) end
})

local autoKickerAccuracy = AutomaticsTab:CreateSlider({
    Name = "Accuracy",
    Range = {0, 100},
    Increment = 1,
    Suffix = "",
    CurrentValue = 100,
    Flag = "AutoKickerAccuracy",
    Callback = function(Value) end
})

local autoKickerRandom = AutomaticsTab:CreateToggle({
    Name = "Random",
    CurrentValue = false,
    Flag = "AutoKickerRandom",
    Callback = function(Value) end
})

-- AutoRush Section
local AutoRushSection = AutomaticsTab:CreateSection("Auto Rush")

local autoRush = AutomaticsTab:CreateToggle({
    Name = "Auto Rush",
    CurrentValue = false,
    Flag = "AutoRush",
    Callback = function(Value) end
})

local autoRushDelay = AutomaticsTab:CreateSlider({
    Name = "Delay",
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = 0.1,
    Flag = "AutoRushDelay",
    Callback = function(Value) end
})

local autoRushPredict = AutomaticsTab:CreateToggle({
    Name = "Predict",
    CurrentValue = false,
    Flag = "AutoRushPredict",
    Callback = function(Value) end
})

-- AutoBoost Section
local AutoBoostSection = AutomaticsTab:CreateSection("Auto Boost")

local autoBoost = AutomaticsTab:CreateToggle({
    Name = "Auto Boost",
    CurrentValue = false,
    Flag = "AutoBoost",
    Callback = function(Value) end
})

local autoBoostPower = AutomaticsTab:CreateSlider({
    Name = "Power",
    Range = {1, 15},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 5,
    Flag = "AutoBoostPower",
    Callback = function(Value) end
})

-- AutoGuard Section
local AutoGuardSection = AutomaticsTab:CreateSection("Auto Guard")

local autoGuard = AutomaticsTab:CreateToggle({
    Name = "Auto Guard",
    CurrentValue = false,
    Flag = "AutoGuard",
    Callback = function(Value) end
})

local autoGuardBind = AutomaticsTab:CreateKeybind({
    Name = "Lock Bind",
    CurrentKeybind = "Q",
    Flag = "AutoGuardBind",
    HoldToInteract = false,
    Callback = function(Keybind) end
})

local autoGuardVisualise = AutomaticsTab:CreateToggle({
    Name = "Visualise",
    CurrentValue = true,
    Flag = "AutoGuardVisualise",
    Callback = function(Value) end
})

local function onCharacterAutomatics(character)
    local leftLeg = character:WaitForChild("Left Leg")
    local rightLeg = character:WaitForChild("Right Leg")

    local humanoid = character:WaitForChild("Humanoid")

    local function onTouch(hit)
        if not hit.Name:match("Arm") and not hit.Name:match("Head") then return end
        if hit:IsDescendantOf(character) then return end

        if humanoid.FloorMaterial ~= Enum.Material.Air then return end
        if not autoBoost.Value then return end

        character.HumanoidRootPart.AssemblyLinearVelocity += Vector3.new(0, autoBoostPower.Value, 0)
    end

    leftLeg.Touched:Connect(onTouch)
    rightLeg.Touched:Connect(onTouch)
end

finishLine:GetPropertyChangedSignal("CFrame"):Connect(function()
    if autoCaptain.Value and not isCatching and finishLine.Position.Y > 0 then
        for i = 1,7,1 do
            task.wait(0.2)
            player.Character.HumanoidRootPart.CFrame = finishLine.CFrame + Vector3.new(0, 2, 0)
        end
    end
end)

player.PlayerGui.ChildAdded:Connect(function(child)
    if child.Name == "KickerGui" and autoKicker.Value then
        local cursor = child:FindFirstChild("Cursor", true)

        if autoKickerRandom.Value then
            autoKickerPower.Value = Random.new():NextNumber(75, 100)
            autoKickerAccuracy.Value = Random.new():NextNumber(75, 100)
        end

        repeat task.wait() until cursor.Position.Y.Scale < 0.01 + ((100 - autoKickerPower.Value) * 0.012) + (fps < 45 and 0.01 or 0)
        mouse1click()
        repeat task.wait() until cursor.Position.Y.Scale > 0.9 - ((100 - autoKickerAccuracy.Value) * 0.001)
        mouse1click()
    end
end)

task.spawn(function()
    local guardLocked = false
    local target = nil

    userInputService.InputBegan:Connect(function(input, gp)
        if gp then return end

        if input.KeyCode == Enum.KeyCode[autoGuardBind.Value] then
            guardLocked = not guardLocked
        end
    end)

    while true do
        task.wait()

        guardUI.Enabled = autoGuard.Value
        guardHighlight.Enabled = autoGuard.Value

        if not autoGuard.Value then continue end

        target = guardLocked and target or findTarget(true)

        if not target then continue end

        local character = player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        local humanoid = character and character:FindFirstChild("Humanoid")

        if not humanoid or not hrp then continue end

        guardHighlight.Adornee = target
        guardUI.Info.Text = "Guarding: "..target.Name.." - Locked: "..tostring(guardLocked)

        local position = target.HumanoidRootPart.Position
        local timeToMoveTo = (hrp.Position - position).Magnitude / 20

        local predictedPosition = position + (target.Humanoid.MoveDirection * timeToMoveTo * 20)

        moveToUsing[#moveToUsing + 1] = os.clock()

        humanoid:MoveTo(predictedPosition)
    end
end)

task.spawn(function()
    while true do
        task.wait()

        local ball = findClosestBall()
        if not ball then continue end

        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

        if not character or not humanoidRootPart then continue end

        local distance = (humanoidRootPart.Position - ball.Position).Magnitude

        if distance < autoCatchRadius.Value and autoCatch.Value then
            mouse1click()
        end

        if distance < autoSwatRadius.Value and autoSwat.Value then
            keypress(0x52)
            keyrelease(0x52)
        end
    end
end)

task.spawn(function()
    local lastTeleported = os.clock()

    while true do
        task.wait()
        if not autoQB.Value then continue end
        if values.Status.Value ~= "PrePlay" then continue end
        if values.PlayType.Value ~= "normal" then continue end
        if values.PossessionTag.Value ~= player.Team.Name then continue end

        local character = player.Character
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        local humanoid = character and character:FindFirstChild("Humanoid")

        if not humanoidRootPart then continue end
        if not humanoid then continue end

        local ball = findClosestBall()
        if not ball then continue end

        if autoQBType.CurrentOption == "Blatant" then
            if (os.clock() - lastTeleported) < 3 then continue end
            lastTeleported = os.clock()
            humanoidRootPart.CFrame = ball.CFrame
        else
            moveToUsing[#moveToUsing + 1] = os.clock()
            humanoid:MoveTo(ball.Position)
        end
    end
end)

task.spawn(function()
    local log = {}

    while true do
        task.wait(1/30)
        local possessor = findPossessor()
        local character = player.Character
        local humanoid = character and character:FindFirstChild("Humanoid")
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

        if not humanoidRootPart then continue end
        if not humanoid then continue end
        if not possessor then log = {} continue end
        if not possessor:FindFirstChild("HumanoidRootPart") then continue end

        local delayedPosition = log[math.max(#log - math.round(autoRushDelay.Value / (1/30)), 1)]

        log[#log + 1] = possessor.HumanoidRootPart.Position

        if not delayedPosition then continue end

        local timeToMoveTo = (humanoidRootPart.Position - delayedPosition).Magnitude / 20
        local predictedPosition = delayedPosition + (possessor.Humanoid.MoveDirection * timeToMoveTo * 20)

        if not autoRush.Value then continue end

        moveToUsing[#moveToUsing + 1] = os.clock()
        humanoid:MoveTo(autoRushPredict.Value and predictedPosition or delayedPosition)
    end
end)

onCharacterAutomatics(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(onCharacterAutomatics)

-- PLAYER SECTION
local SpeedSection = PlayerTab:CreateSection("Speed")

local speed = PlayerTab:CreateToggle({
    Name = "Speed",
    CurrentValue = false,
    Flag = "Speed",
    Callback = function(Value) end
})

local speedValue = PlayerTab:CreateSlider({
    Name = "Speed Value",
    Range = {20, 23},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 21.5,
    Flag = "SpeedValue",
    Callback = function(Value) end
})

local JumpPowerSection = PlayerTab:CreateSection("Jump Power")

local jumpPower = PlayerTab:CreateToggle({
    Name = "Jump Power",
    CurrentValue = false,
    Flag = "JumpPower",
    Callback = function(Value) end
})

local jumpPowerValue = PlayerTab:CreateSlider({
    Name = "Power",
    Range = {50, 70},
    Increment = 1,
    Suffix = "",
    CurrentValue = 60,
    Flag = "JumpPowerValue",
    Callback = function(Value) end
})

local AngleEnhancerSection = PlayerTab:CreateSection("Angle Enhancer")

local angleEnhancer = PlayerTab:CreateToggle({
    Name = "Angle Enhancer",
    CurrentValue = false,
    Flag = "AngleEnhancer",
    Callback = function(Value) end
})

local angleEnhancerJP = PlayerTab:CreateSlider({
    Name = "JP",
    Range = {50, 70},
    Increment = 1,
    Suffix = "",
    CurrentValue = 60,
    Flag = "AngleEnhancerJP",
    Callback = function(Value) end
})

local angleEnhancerIndicator = PlayerTab:CreateToggle({
    Name = "Indicator",
    CurrentValue = false,
    Flag = "AngleEnhancerIndicator",
    Callback = function(Value) end
})

local ReplicationLagSection = PlayerTab:CreateSection("Replication Lag")

local replicationLag = PlayerTab:CreateToggle({
    Name = "Replication Lag",
    CurrentValue = false,
    Flag = "ReplicationLag",
    Callback = function(Value) end
})

local replicationLagValue = PlayerTab:CreateSlider({
    Name = "Lag",
    Range = {0, 100},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = 0,
    Flag = "ReplicationLagValue",
    Callback = function(Value) end
})

local function onCharacterMovement(character)
    local humanoid = character:WaitForChild("Humanoid")
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    task.spawn(function()
        while AC_BYPASS and humanoid.Parent do
            task.wait(.1)
            humanoid.JumpPower = jumpPower.Value and jumpPowerValue.Value or 50
        end
    end)

    humanoid.Jumping:Connect(function()
        if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
        if AC_BYPASS then return end
        task.wait(0.05)
        if jumpPower.Value then
            humanoidRootPart.AssemblyLinearVelocity += Vector3.new(0, jumpPowerValue.Value - 50, 0)
        end
    end)
end

onCharacterMovement(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(onCharacterMovement)

task.spawn(function()
    while true do
        task.wait()
        if not replicationLag.Value then
            settings():GetService("NetworkSettings").IncomingReplicationLag = 0
            continue
        end

        settings():GetService("NetworkSettings").IncomingReplicationLag = replicationLagValue.Value / 100
    end
end)

task.spawn(function()
    local angleTick = os.clock()
    local oldLookVector = Vector3.new(0, 0, 0)

    local shiftLockEnabled = false
    local lastEnabled = false

    local function hookCharacter(character)
        local humanoid = character:WaitForChild("Humanoid")
        local hrp = character:WaitForChild("HumanoidRootPart")

        humanoid.Jumping:Connect(function()
            if humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then return end
            if os.clock() - angleTick > 0.2 then return end
            if not angleEnhancer.Value then return end

            if angleEnhancerIndicator.Value then
                local h = Instance.new("Hint")
                h.Text = "Angled"
                h.Parent = workspace

                debris:AddItem(h, 1)
            end

            if AC_BYPASS then return end

            task.wait(0.05); hrp.AssemblyLinearVelocity += Vector3.new(0, angleEnhancerJP.Value - 50, 0)
        end)
    end

    hookCharacter(player.Character or player.CharacterAdded:Wait())

    player.CharacterAdded:Connect(hookCharacter)

    userInputService:GetPropertyChangedSignal("MouseBehavior"):Connect(function()
        if userInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
            shiftLockEnabled = true
        else
            shiftLockEnabled = false
        end
    end)

    while true do
        task.wait()
        local character = player.Character; if not character then continue end
        local hrp = character:FindFirstChild("HumanoidRootPart"); if not hrp then continue end
        local humanoid = character:FindFirstChild("Humanoid"); if not humanoid then continue end

        local lookVector = hrp.CFrame.LookVector
        local difference = (oldLookVector - lookVector).Magnitude

        if not shiftLockEnabled and lastEnabled then
            angleTick = os.clock()
        end

        if AC_BYPASS then
            if (os.clock() - angleTick < 0.2) and angleEnhancer.Value then
                humanoid.JumpPower = (jumpPower.Value and jumpPowerValue.Value or 50) + (angleEnhancerJP.Value - 50)
            elseif not angleEnhancer.Value then
                humanoid.JumpPower = (jumpPower.Value and jumpPowerValue.Value or 50)
            end
        end

        oldLookVector = hrp.CFrame.LookVector
        lastEnabled = shiftLockEnabled
    end
end)

runService:BindToRenderStep("walkSpeed", Enum.RenderPriority.Character.Value, function()
    local character = player.Character
    local humanoid = character and character:FindFirstChild("Humanoid")

    if not character or not humanoid then return end
    if humanoid:GetState() ~= Enum.HumanoidStateType.Running then return end
    if humanoid.WalkSpeed == 0 and not noFreeze.Value then return end
    if not character:FindFirstChild("HumanoidRootPart") then return end

    local moveDirection = ((os.clock() - (moveToUsing[#moveToUsing] or 0)) < 0.5 and (humanoid.WalkToPoint - character.HumanoidRootPart.Position).Unit) or (humanoid.MoveDirection)
    local currentVel = character.HumanoidRootPart.AssemblyLinearVelocity

    if speed.Value or noFreeze.Value then
        local speedVal = speed.Value and (speedValue.Value > 20 and speedValue.Value) or 20
        character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(moveDirection.X * speedVal, currentVel.Y, moveDirection.Z * speedVal)
    end
end)

-- CONFIGS SECTION
local SaveConfigSection = ConfigsTab:CreateSection("Save Config")

local SaveConfig = ConfigsTab:CreateButton({
    Name = "Save Config",
    Callback = function()
        configSavingUI.Enabled = true

        local configName = nil

        local connection; connection = configSavingUI.Frame.ConfirmButton.MouseButton1Click:Connect(function()
            configName = configSavingUI.Frame.ConfigName.Text
            connection:Disconnect()
        end)

        repeat task.wait() until configName

        configSavingUI.Enabled = false

        local exported = Rayfield:SaveConfiguration()

        writefile("Eclipse Hub/"..configName..".json", exported)
    end
})

local LoadConfigSection = ConfigsTab:CreateSection("Load Config")

local LoadConfig = ConfigsTab:CreateButton({
    Name = "Load Config",
    Callback = function()
        configSavingUI.Enabled = true

        local configName = nil

        local connection; connection = configSavingUI.Frame.ConfirmButton.MouseButton1Click:Connect(function()
            configName = configSavingUI.Frame.ConfigName.Text
            connection:Disconnect()
        end)

        repeat task.wait() until configName

        configSavingUI.Enabled = false

        if not isfile("Eclipse Hub/"..configName..".json") then return end

        local contents = readfile("Eclipse Hub/"..configName..".json")

        Rayfield:LoadConfiguration(contents)
    end
})

-- Load Configuration at the end
Rayfield:LoadConfiguration()
